<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[06 Spring Boot 之文件上传]]></title>
    <url>%2F2018%2F09%2F03%2F06%20Spring-Boot%20%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[Spring Boot的文件上传，常使用MultipartFile类，该类源自SpringMVC。 一、【文件上传三要素】： 表单提交方式：method=&quot;post&quot;。 表单类型：enctype=&quot;multipart/form-data&quot;。 表单项中有一个或者多个的file类型。 二、【编写HTML页面】： 12345&lt;form enctype="multipart/form-data" method="post" action="/upload"&gt; 文件:&lt;input type="file" name="head_img"/&gt; 姓名:&lt;input type="text" name="name"/&gt; &lt;input type="submit" value="上传"/&gt;&lt;/form&gt; 三、【编写Controller】： 1234567891011121314151617181920212223242526272829303132333435@RequestMapping(value = "upload")@ResponseBodypublic JsonData upload(@RequestParam("head_img") MultipartFile file,HttpServletRequest request) &#123; //file.isEmpty(); 判断图片是否为空 //file.getSize(); 图片大小进行判断 String name = request.getParameter("name"); System.out.println("用户名："+name); // 获取文件名 String fileName = file.getOriginalFilename(); System.out.println("上传的文件名为：" + fileName); // 获取文件的后缀名,比如图片的jpeg,png String suffixName = fileName.substring(fileName.lastIndexOf(".")); System.out.println("上传的后缀名为：" + suffixName); // 文件上传后的路径 fileName = UUID.randomUUID() + suffixName; System.out.println("转换后的名称:"+fileName); File dest = new File(filePath + fileName); try &#123; file.transferTo(dest); return new JsonData(0, fileName); &#125; catch (IllegalStateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new JsonData(-1, "fail to save ", null);&#125; MultipartFile对象的transferTo方法，用于文件保存，效率和操作比原先使用fileOutStream方便和高效。 四、【Spring Boot 对上传文件大小的配置】： Spring Boot 默认对上传文件的大小限制是：每个文件的配置最大为1Mb，单次请求的文件的总数不能大于10Mb 。 配置上传文件大小有两种方式： 1、方式一：配置文件配置： 12spring.servlet.multipart.max-file-size=30Mb spring.servlet.multipart.max-request-size=30Mb 需要注意的是，如果是Spring Boot 1.5.x的配置是： 123&gt; spring.http.multipart.max-file-size=30Mb &gt; spring.http.multipart.max-request-size=30Mb&gt; 2、方式二：注入Bean： 123456789@Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //单个文件最大 factory.setMaxFileSize("10240KB"); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize("1024000KB"); return factory.createMultipartConfig(); &#125; 五、【自定义文件上传路径】： 在配置文件中，自定义文件需要上传的路径： 12web.images-path=/Users/enhao/Desktopspring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/test/,file:$&#123;web.upload-path&#125; 上传路径的key可以自定义。然后将其添加到静态资源路径下（static-locations），这样可以直接访问到。 然后程序中直接引用配置文件中的路径即可。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Spring Boot 之web开发]]></title>
    <url>%2F2018%2F09%2F02%2F05%20Spring%20Boot%20%E4%B9%8Bweb%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1 Spring Boot 对静态资源的映射规则Spring MVC 的自动配置在WebMvcAutoConfiguration类中。 资源映射配置的方法：addResourceHandlers()。 欢迎页的配置：welcomePageHandlerMapping()。 1、所有的/webjars/**路径访问，都去classpath:/META-INF/resources/webjars/下找资源。 webjars：以jar包的方式引入静态资源。可以像引入其他依赖一样，将静态资源的依赖引入到项目中。依赖网址：https://www.webjars.org 例如：引入jquery依赖： 123456&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt;&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt;&gt; &lt;version&gt;3.3.0&lt;/version&gt;&gt; &lt;/dependency&gt;&gt; 访问资源的路径：localhost:8080/webjars/jquery/3.3.0/jquery.js。就会到/META-INF/resources/webjars/下找。 2、/**路径的访问：访问当前项目的任何资源，会从以下路径查找： 12345classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public// : 当前项目的根路径 类路径：java和resources文件夹下路径都是类路径的根目录。 可以使用spring.resources.static-locations来配置静态资源路径。 加载顺序：META/resources、resources、static、public。所以相同名称的资源文件会按照加载顺序优先加载。 3、欢迎页：静态资源文件夹下的所有index.html页面，被/**映射。 4、网站的图标：**/favicon.ico都在静态资源文件下找。 注：实际开发中，一般是做前后端分离的，静态资源文件一般都不放在java项目中。静态资源文件都存储在CDN。 2 模板引擎：Thymeleaf2.1 引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 注意：如果使用的是Spring Boot 1.5.x 版本，默认的thymeleaf的版本是2.1。若想将thymeleaf切换到3.x版本，需要在pom的&lt;properties&gt;标签下配置： 12345&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- thymeleaf3.x布局功能的版本layout需要2.x以上版本 --&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 2.2 Thymeleaf使用&amp;语法1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html";&#125; 只要我们把HTML页面放在classpath:/templates/目录下，Thymeleaf就可以自动渲染了。 【导入名称空间】： 在html标签上导入thymeleaf的名称空间：xmlns:th=&quot;http://www.thymeleaf.org&quot;。目的是为了由代码提示。 2.2.1 th:任意属性使用th:任意html属性：来替换元素属性的值。 1&lt;div id="111" th:id="#&#123;id&#125;"&gt;&lt;/div&gt; 通过thymeleaf引擎，th:id的值会将id的值替换掉。 th:text：修改标签体内容，转义特殊字符；th:utext：不转义特殊字符。 它们的行内写法：th:text：[[]]。 th:utext：[()] 2.2.2 表达式一、【Simple expressions】：简单表达式 123456Simple expressions: Variable Expressions: $&#123;...&#125; Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; Link URL Expressions: @&#123;...&#125; Fragment Expressions: ~&#123;...&#125; 1、${...}：变量表达式，底层是OGNL表达式。 获取对象属性，调用方法。和OGNL一样。 使用内置基本对象。以#开头：例： 1$&#123;#locale.country&#125; 1234567#ctx : the context object.当前上下文对象。#vars: the context variables.当前上下文变量值。#locale : the context locale.当前上下文区域信息。#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object 内置的工具对象： 1234567891011121314151617#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as theywould be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). 2、*{..}：选择变量表达式。和${}在功能上一样。有一个不从功能，配合th:object使用： 12345&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 使用th:object获取到一个对象，可以使用*{}来获取到对象中的每个属性。等同于： 123456&gt; &lt;div&gt;&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;session.user.firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;&gt; &lt;p&gt;Surname: &lt;span th:text="$&#123;session.user.lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&gt; &lt;p&gt;Nationality: &lt;span th:text="$&#123;session.user.nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&gt; &lt;/div&gt;&gt; 3、#{...}：获取国际化内容的。 4、@{...}：定义URL。 1234567&lt;!-- Will produce 'http://localhost:8080/gtvg/order/details?orderId=3' (plus rewriting) --&gt;&lt;a href="details.html"th:href="@&#123;http://localhost:8080/gtvg/order/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/details?orderId=3' (plus rewriting) --&gt;&lt;a href="details.html" th:href="@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/3/details' (plus rewriting) --&gt;&lt;a href="details.html" th:href="@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt; 如果由多个参数可以写成：@{/order/process(execId=${execId},execType=&#39;FAST&#39;)}。 5、~{...}：片段引用表达式。 二、【字面量】：字符串、数字，布尔，null，多个数字逗号隔开。 123456Literals: Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… 三、【文本操作】： 123Text operations: String concatenation: + ：字符串拼接 Literal substitutions: |The name is $&#123;name&#125;| ： 字符串替换 四、【数学运算】： 123Arithmetic operations: Binary operators: + , - , * , / , % Minus sign (unary operator): - 五、【其他】： 123456789101112131415Boolean operations: 布尔运算 Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality: 比较运算 Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators: 条件运算 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: 特殊操作 No-Operation: _ 无操作 2.2.3 公共页面抽取一、使用th:fragment声明抽取的公共片段。 二、使用th:insert/th:replace/th:include引入公共片段。 th:insert：将公共片段整个插入到声明引入的元素中。 th:replace：将声明引入的元素替换为公共片段。 th:include：将被引入的片段的内容包含到声明引入的元素中。 表达式：&quot;~{模板名::选择器}&quot;或者&quot;~{模板名::片段名}&quot;。 模板名：th:fragment所在的模板名。 3 SpringMVC 自动配置原理Spring MVC 的自动配置在WebMvcAutoConfiguration类中。 Spring Boot 对 Spring MVC 的默认配置如下： 一、自动配置了ContentNegotiatingViewResolver和BeanNameViewResolver 视图解析器。 ContentNegotiatingViewResolver：组合所有的视图解析器。ContentNegotiatingViewResolver不是自己处理View，而是代理给不同的ViewResolver来处理不同的View，所以它有最高的优先级。 我们可以自己向容器中添加一个视图解析器，ContentNegotiatingViewResolver会将其自动组合进来。 二、静态资源映射：静态资源文件夹路径和webjars。 三、静态首页访问index.html。 四、自定义网站图标favicon.ico。 五、自动注册了Converter、Genericconverter、Formatter的beans。 Converter：转换器。 Formatter：格式化器。例如格式化日期。 日期格式化器，需要在文件中配置spring.mvc.date-format才生效。 我们可以自己向容器中添加的格式化转换器，自动配置会自动注册。 六、支持HttpMessageConverters。 HttpMessageConverters： Spring MVC用来转换HTTP请求和相应的。 我们可以自己向容器中添加HttpMessageConverters，只需要将自己的组件注册到容器中。 4 扩展 Spring MVC（重要）如果我们想保留Spring Boot 对MVC的自动配置，并且向添加一些额外的MVC配置，例如拦截器，转换器，视图解析器等等。我们可以编写一个配置类，实现WebMvcConfigurer接口，但是不能标注@EnableWebMvc。 这样既保留了所有的自动配置。也可以用我们自己的配置。 以添加视图映射为例： 12345678@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/hello").setViewName("success"); &#125;&#125; 注意：在Spring Boot 1.5.x中，扩展Spring MVC 时需要配置类继承WebMvcConfigurerAdapter接口。WebMvcConfigurerAdapter是WebMvcConfigurer的空实现。 因为Spring Boot 2.x是以Spring framework 5为基础，其底层是java8实现，java8中的接口有默认方法（default method），因此就不在需要一个适配器（adapter）进行空实现了。 5 全面接管Spring MVC（不推荐）如果想全面接管Spring MVC，即不使用 Spring Boot 对 MVC 的自动配置，需要在配置类中添加@EnableWebMvc即可。 为什么添加了EnableWebMvc注解后，Spring MVC 的自动配置不起作用了呢？ 我们看WebMvcAutoConfiguration注解： 123456789@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;&#125; 其中：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)的意思是若容器中没有WebMvcConfigurationSupport这个类，WebMvcAutoConfiguration自动配置才生效。 这是我们看@EnableWebMvc注解： 123@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125; 它导入了一个DelegatingWebMvcConfiguration类： 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;&#125; 发现这个类就是WebMvcConfigurationSupport类型的类。因此WebMvcAutoConfiguration自动配置类不生效。 6 国际化步骤： 一、【编写国际化配置文件，抽取页面需要显示的国际化消息】。 login_en_US.properties： 12345login.password=Passwordlogin.rememberMe=Remember Melogin.signIn=Sign Inlogin.tip=Please sign inlogin.username=Username login_zh_CN.properties: 12345login.password=密码login.rememberMe=记住我login.signIn=登录login.tip=请登录login.username=用户名 二、【Spring Boot 自动配置好了管理国际资源文件的组件】。 国际化资源文件的默认基础名是message.properties。使用spring.messages.basename可以自定义基础名： 基础名：没有语言和国家的。login.properties就是基础名。 1spring.messages.basename=i18n.login 三、【在页面获取国际化的值】。 使用#{}获取国际化信息的值。 标签体中使用th:text=&quot;#{}&quot;获取国际化值。 没有标签体的使用[[#{}]]获取国际化值。 四、【中英文手动切换】。 原理：国际化Locale（区域信息对象）；使用LocaleResolver获取区域信息对象。 MVC自动配置中，默认配置了区域信息解析器LocaleResolver。Spring Boot 默认使用AcceptHeaderLocaleResolver，根据请求头Accept-Language获取区域信息进行国际化。 我们可以自定义一个LocaleResolver区域信息解析器，可以在链接上携带区域信息 123456789101112131415161718@Component("localeResolver")public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String language = httpServletRequest.getParameter("language"); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(language)) &#123; String[] languages = language.split("_"); locale = new Locale(languages[0], languages[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 需要注意的是，自定义区域信息解析器bean的名称必须是localeResolver。 如果url上带的参数上有language信息，使用参数的语言信息，如果没有就使用操作系统默认的语言。 th:href=&quot;@{/login.html(language=&#39;zh_CN&#39;)}&quot; 7 页面上发送PUT请求步骤一：SpringMVC中配置HiddenHttpMethodFilter。（Spring Boot 已自动配置） 步骤二：页面上创建一个post表单。 步骤三：创建一个input项，name为_method，value为指定的请求方式。 1&lt;input type="hidden" name="_method" value="put"/&gt; 8 错误处理机制8.1 Spring Boot 默认的错误处理机制一、在浏览器中返回一个默认的错误页面。 二、在其他客户端，默认响应一个json数据：例如： 1234567&#123; "timestamp": 1530441885182, "status": 404, "error": "Not Found", "message": "No message available", "path": "/aads"&#125; 原理：参照ErrorMvcAutoConfiguration错误自动配置类。 自动配置给容器添加了以下组件： 1、DefaultErrorAttributes：在页面共享信息。 2、BasicErrorController：处理默认/error请求。 123456789101112131415161718192021222324@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html") // 产生html类型的数据，浏览器发送的请求，请求头带有`text/html` public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); // 去哪个页面作为错误页面：包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody // 产生json数据 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125;&#125; 3、ErrorPageCustomizer：系统出现错误后，来到/error请求进行处理。 4、DefaultErrorViewResolver：Spring Boot默认去找error/状态码页面。如果模板引擎可以解析这个页面就用模板引擎解析，并返回视图地址。模板引擎不可用，就在静态资源文件下找对应的页面。 步骤：一旦系统出现4xx或者5xx之类的错误。ErrorPageCustomizer就会生效（定制错误响应的规则），就会来到/error请求。就会被BasicErrorController处理：1）响应的去哪个页面，由DefaultErrorViewResolver解析得到的。 8.2 定制错误处理一、【定制错误页面】： 情况一：有模板引擎情况下（模板引擎可以解析错误页面）：error/状态码（例如：error/404），将错误页面命名为错误状态码.html放在模板引擎文件夹里的error文件夹下，发生此状态码的错误就会来到这个页面。 可以使用4xx/5xx作为文件名来匹配这种类型的所有错误。原则是精确优先。优先寻找有精确的状态码的html页面。 页面可以获取的信息： 123456timestamp:时间戳status：状态码error：错误提示exception：异常对象message：异常消息errors：JSR303数据校验的错误。 情况二：没有模板引擎（模板引擎找不到这个错误页面），在静态资源文件夹（static/resources/public）下找。（了解） 情况三：以上两种都没有，使用Spring Boot默认错误页面。 二、【定制错误的json数据】： 通过定制ErrorAttribute改变需要返回的内容。 9 配置嵌入式Servlet容器（Spring Boot 1.5.x）Spring Boot 默认使用的是嵌入式的Servlet容器。 9.1 定制和修改Servlet容器相关配置一、修改和server有关的配置： 方式一：ServerProperties，例如： 1234567# 配置端口号server.port=8081# 配置项目名称server.context-path=/crud# tomcat设置server.tomcat.uri-encoding=UTF-8 方式二：编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器定制器。 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 以上两种方式，表现形式不同，但原理一样，都是实现EmbeddedServletContainerCustomizer来实现的。 9.2 注册Servlet的三大组件在以前的项目中，Servlet三大组件的注册信息放在了/WEB-INF/web.xml中。Spring Boot 中没有该配置文件。 因此注册三大组件，需要使用ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean： 123456789101112131415161718@Beanpublic ServletRegistrationBean myServlet() &#123; return new ServletRegistrationBean(new MyServlet(), "/myServlet");&#125;@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125;@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; Spring Boot 帮我们自动注册DispatcherServlet用的就是这种方式。 9.3 使用其他的嵌入式Servlet容器默认使用的是Tomcat,所以切换容器时,需要先排除Tomcat的依赖,然后引入需要切换的对应容器的依赖。 一、切换 Jetty：适合做长连接 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 二、Undertow：不支持JSP 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt; 9.4 嵌入式Servlet容器自动配置原理EmbeddedServletContainerAutoConfiguration：嵌入式Servlet容器自动配置。 一、Spring Boot根据导入的依赖情况，给容器中添加嵌入式容器工厂EmbeddedServletContainerFactory（例如：TomcatEmbeddedServletContainerFactory）。 二、容器中某个组件要创建对象就会惊动后置处理器， EmbeddedServletContainerCustomizerBeanPostProcessor，只要是嵌入式容器工厂，后置处理器就工作， 三、后置处理器从容器中获取所有的嵌入式Servlet容器定制器EmbeddedServletContainerCustomizer，调用定制器的定制方法(customize)。 9.5 嵌入式Servlet容器启动原理一、什么时候创建嵌入式Servlet容器工厂？ SpringBoot应用启动运行main方法。 Spring Boot刷新IOC容器refreshContext（创建IOC容器并初始化容器，创建容器中的每一个组件）。 web的IOC容器重写了onRefresh方法，会创建嵌入式Servlet容器。获取嵌入式Servlet容器工厂。从容器中获取EmbeddedServletContainerFactory。TomcatEmbeddedServletContainerFactory创建对象。 二、什么时候获取嵌入式Servlet容器并启动Tomcat？ 使用嵌入式Servlet容器工厂，获取嵌入式Servlet容器，创建Tomcat对象，并启动Tomcat。 先启动嵌入式Servlet容器，再将容器中剩下没有创建的对象获取出来。 IOC容器启动的时候创建嵌入式Servlet容器。 10 使用外置Servlet容器使用嵌入式Servlet容器的缺点是不支持JSP。 可以使用外置的Servlet容器，应用打包成war包。 将tomcat的依赖改成provided。 打成war包的Spring Boot项目多了一个ServletInitializer 。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Spring Boot 之日志]]></title>
    <url>%2F2018%2F09%2F01%2F04%20Spring%20Boot%20%E4%B9%8B%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1 日志框架 日志门面 （日志抽象层） 日志实现 JCL(Jakarta Commons Logging)、SLF4j(Simple Logging Facade for Java)、jboss-logging Log4j、JUL(java.util.logging)、Log4j2、 Logback 左边选一个抽象层，右边选一个实现： 最常用的日志门面：SLF4J。 日志实现：Log4J和Logback是一个写的框架。Log4J2是Apache出的。 Spring Boot 选用的是SLF4J和Logback。 2 SLF4J 使用 日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层的方法（和JDBC一样，面向接口编程）。 需要给项目里导入slf4J和logback的jar。 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每个日志框架都有自己的配置文件，使用slf4j以后，配置文件还是做出日志实现框架自己本身的配置文件。 3 遗留问题：统一日志在项目中我们会用到不同的框架，但这些不同的框架各自所使用的日志框架也是不同的，例如 Spring 用的是commons-logging，hibernate 用的是 jboss-logging。 所以需要统一日志记录，统一使用slf4j和logback。 下面这张图展示了怎样统一使用slf4j日志。 步骤一：将系统中其他日志框架先排除除去。 步骤二：用中间包来替换原有的日志框架。 步骤三：导入slf4j包和其他的实现日志包。 4 Spring Boot 日志关系Spring Boot 使用spring-boot-starter-logging来做日志功能。 Spring Boot 日志的依赖关系： 一、Spring Boot 底层使用的是slf4j+logback的方式进行日志记录。 二、Spring Boot 也把其他的日志都替换成了slf4j。 三、如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉。 5 Spring Boot 日志默认配置Spring Boot 默认已经配置好了日志了，默认的日志级别是info。 日志级别由低到高：trace &lt; debug &lt; info &lt; warn &lt; error。 5.1 修改日志级别格式：logging.level.* = LEVEL logging.level：日志级别控制前缀，*为包名或Logger名 。 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF logging.level.root=debug：配置root的日志级别。 logging.level.包名=debug：配置指定包下的日志级别。 5.2 指定日志输出位置如果不指定logging.file或者logging.path，日志只在控制台输出。 使用logging.file指定文件名，将日志输出到指定的文件中。可以是绝对路径，也可以是相对路径。 logging.file=my.log：日志放在当前项目根路径下。 logging.file=/my.log：日志放在当前磁盘根路径下。 使用logging.path指定目录。 logging.path=/spring/log：在当前磁盘的根路径下创建spring文件夹和log文件夹，日志文件使用默认的spring.log。 如果logging.file和logging.path同时配置，只有logging.file起作用。 5.3 指定日志输出的格式logging.pattern.console：指定在控制台输出的日志的格式。 logging.pattern.file：指定文件中日志输出的格式。 6 指定日志框架配置文件给类路径下放上日志框架自己的配置文件即可，Spring Boot 就不使用他默认的配置了。 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 推荐使用带有-spring后缀的日志名称。 如果使用logback.xml名称的，就直接被日志框架识别了。 如果使用logback-spring.xml带有-spring后缀的日志名称，日志框架就不直接加载日志的配置文件了，由Spring Boot 加载，因此可以使用Spring Boot的多环境配置功能springProfile。 123&lt;springProfile name="dev"&gt; ...&lt;/springProfile&gt; 可以指定某段配置只在某个环境下生效。通过spring.profiles.active来配置当前激活的profile。 7 切换日志框架7.1 切换到 log4j (不推荐)按照slf4j的日志是配图，进行相关切换。 slf4j + log4j的方式： 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换到log4j，需要创建log4j的日志配置文件log4j.properties。 7.2 切换到 log4j21234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Spring Boot 之自动配置]]></title>
    <url>%2F2018%2F08%2F11%2F03%20Spring%20Boot%20%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我们可以在application.properties/application.yml文件中或通过命令行指定各种的属性。可以配置的属性见官方参考文档：Common application porperties。 1 自动配置原理1.1 @EnableAutoConfigurationSpring Boot 启动的时候，加载主配置类，使用@EnableAutoConfiguration（@SpringBootApplication组合注解里的一个），开启了自动配置功能。 @EnableAutoConfiguration注解作用是利用EnableAutoConfigurationImportSelector选择器给容器中导入一些组件。该选择器扫描所有jar包类路径下的META-INF/spring.factories文件。获取文件中key为EnableAutoConfiguration类名对应的值，然后将他们添加到容器中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的XxxAutoConfiguration类都是容器中的一个组件，作用就是用来进行自动配置。 1.2 以 HttpEncodingAutoConfiguration 为例123456789101112131415161718192021222324252627282930// 这是一个配置类@Configuration// 启用指定类的ConfigurationProperties，将配置文件和HttpEncodingProperties绑定，并把HttpEncodingProperties添加到容器中。@EnableConfigurationProperties(HttpEncodingProperties.class)// 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication// 判断当前项目有没有CharacterEncodingFilter类，如果有，当前配置类生效// CharacterEncodingFilter：springmvc中处理乱码的过滤器@ConditionalOnClass(CharacterEncodingFilter.class)// 判断配置文件中是否存在spring.http.encoding.enabled这个配置。matchIfMissing表示如果不存在，判断也成立（即使配置文件中不配置spring.http.encoding.enabled，当前配置类也生效）@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; // HttpEncodingProperties和配置文件进行映射了，可以直接取里面的值。 private final HttpEncodingProperties properties; // 当只有一个有参构造器的情况下，参数的值就会从容器中获取 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean // 当容器中没有CharacterEncodingFilter类，配置生效 @ConditionalOnMissingBean(CharacterEncodingFilter.class) public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125;&#125; 根据当前不同的条件判断，决定这个配置类是否生效。一旦这个配置类生效，这个配置类就会给容器中添加各种组件，这个组件的属性是从对应的properties类中获取的，这些properties类里面的每一个属性又是和配置文件绑定的。 @HttpEncodingProperties：所有可以在配置文件中配置的属性都是在XxxProperties类中封装。因此，配置文件中可以配置的数据就可以参照每一个自动配置的属性类。 123// 从配置文件中获取指定的值，并和bean进行绑定@ConfigurationProperties(prefix = "spring.http.encoding")public class HttpEncodingProperties &#123;&#125; 1.3 总结XxxAutoConfiguration：自动配置类，配置类一旦生效，就会给容器中添加组件。 XxxProperties：封装配置文件中相关的属性。 一、Spring Boot 启动时会加载大量的自动配置类。 二、自动配置类生效时已经自动配置了一些组件，已经配置的组件，就不需要我们自己配置了。 三、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性值，我们就可以在配置文件中指定这些属性值。 2 @Conditional 派生注解Spring 框架有@Conditional条件注解，只有当条件注解中的条件生效，对应的配置类配置的内容才会生效。 Spring Boot 对条件注解进行了扩展： @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 3 自动配置报告自动配置类只有在一定的条件下才能生效。我们怎么才能知道哪些自动配置类生效了，哪些没有生效呢？ 此时我们可以开启Spring Boot 的 debug模式。 在application.properties/application.yml配置文件中配置：debug=true。这样可以在控制台打印自动配置报告。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 Spring Boot 之配置文件]]></title>
    <url>%2F2018%2F08%2F07%2F02%20Spring%20Boot%20%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1 Spring Boot 配置文件Spring Boot 使用一个全局的配置文件。配置文件有两种类型：application.properties或者application.yml。配置文件放置在src/main/resources目录下。配置文件名是固定的。 配置文件的作用：修改 Spring Boot 自动配置的默认值。 1.1 YAML 语法YAML是以数据为中心，而不是以置标语言为重点 ，比xml更适合做配置文件。 1.1.1 基本语法key: value：表示一对键值对。注意：key 和 value 之间必须要有空格。 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的。 属性和值是大小写敏感的。 123server: port: 8081 path: /hello 1.1.2 值的写法一、【字面量】：普通的值（数字、字符串、布尔）。 字面量直接来写，字符串默认不用加上单引号或者双引号。 &quot;&quot;：双引号，不会转义字符串里面的特殊字符。特殊字符原样输出。 &#39;&#39;：单引号，会转义字符串里面的特殊字符。 二、【对象、Map（属性和值）】： 值是对象的时候，还是用key: value的形式，表示值。 1234friend: firstName: liang lastName: enhao age: 18 行内写法： 1friend: &#123;firstName: liang, lastName: enhao, age: 18&#125; 三、【数组（List、Set）】： 用- 值的方式表示数据中的一个元素。 1234pets: - cat - dog - pig 行内写法： 1pets: [cat, dog, pig] 1.2 配置文件值获取： @ConfigurationProperties1.2.1 使用方法首先，YAML配置文件属性如下： 123456789101112person: lastName: enhao age: 18 boss: false birth: 2018/06/17 map: &#123;key1: xixixi, key2: 12&#125; lists: - zhangsan - lisi dog: name: dog age: 2 要想配置文件的值和bean的值一一绑定，需要使用@ConfigurationProperties。该注解默认从全局配置文件application.properties/application.yml中获取值。 123456789101112@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog;&#125; 通过属性prefix指定前缀，只要是指定前缀的key，Spring Boot 就会将该前缀key的value映射到标注了@ConfigurationProperties注解的bean中。 导入配置文件处理器，在编写配置文件时就可以有提示了。 123456&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&gt; &lt;optional&gt;true&lt;/optional&gt;&gt; &lt;/dependency&gt;&gt; 1.2.2 @ConfigurationProperties 和 @Value 区别@ConfigurationProperties 和 @Value都可以获取到配置文件中的值，但他们有一些区别： @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 SpEL（#{}） 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装（Map，List） 支持 不支持 松散绑定：对属性名称匹配规则： 标准的：person.lastName 松散语法：person.last-name JSR303数据校验：可以使用@Validated进行数据校验。 12345678&gt; @Component&gt; @ConfigurationProperties(prefix = "person")&gt; @Validated&gt; public class Person &#123;&gt; @Email&gt; private String email;&gt; &#125;&gt; 校验必须时email格式的。 总结：我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value注解。如果我们专门编写一个JavaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。 1.3 加载指定配置文件：@PropertySource由于@ConfigurationProperties注解默认是从全局配置文件application.properties/application.yml中获取值的。如果要从其他配置文件中获取值时，就需要使用@PropertySource，来读取指定的配置文件，其属性value可以指定一个数据值，读取多个配置文件的值。 123456@Component@ConfigurationProperties(prefix = "person")@PropertySource(value = &#123;"classpath:person.properties"&#125;)public class Person &#123; private String lastName;&#125; 读取类路径下person.properties配置文件。并将其映射到bean中。 1.4 导入Spring的配置文件：@ImportResourceSpring Boot 项目里面没有Spring的配置文件，我们自己编写的Spring配置文件不能自动的识别。如果想让Spring的配置文件生效，就需要使用@ImportResource。将其标注在一个配置类上。 感觉没啥用 (￣▽￣)” 1234567@SpringBootApplication@ImportResource(locations = &#123;"classpath:applicationContext.xml"&#125;)public class SpringBoot02ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 1.5 配置文件占位符YAML和properties两种形式的配置文件都支持占位符。 一、【占位符获取随机数】： 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.uuid&#125; 二、【占位符获取之前配置的值，如果没有可以用:指定默认值】： 123person.last-name=enhao $&#123;random.uuid&#125;person.dog.name=$&#123;person.last-name&#125;_dogperson.age=$&#123;person.age:18&#125;_3 2 配置文件加载位置Spring Boot 启动的时候会扫描以下位置的application.properties或者application.yml文件作为默认配置文件。 file:/config/ file:./ classpath:/config/ classpath:/ 以上优先级由高到低，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。 我们还可以通过spring.config.location来改变默认的配置文件的位置。 通常是项目打包好后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置。指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。 3 外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。 命令行参数 。 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件。 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件。 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 。 jar包内部的application.properties或application.yml(不带spring.profile)配置文件。 @Configuration注解类上的@PropertySource。 通过SpringApplication.setDefaultProperties指定的默认属性 。 着重关注1、6、7、8、9。 由jar包外向jar包内进行寻找。优先加载带profile。 4 Profile 多环境支持Profile 是 Spring 对不同环境提供不同配置的支持，可以通过激活、指定参数等方式快速切换环境。 4.1 方式一：多个profile文件方式主配置文件使用格式为：application-{profile}.properties。编写不同环境的配置文件。 默认使用的是application.properties文件。 可以使用spring.profile.active来激活指定的profile。 4.2 方式二：YAML多文档块方式在YAML配置文件中，使用---来将配置文件划分为多个文档块。 12345678910111213spring: profiles: active: dev---spring: profiles: devserver: port: 8081---spring: profiles: prodserver: port: 8082 使用spring.profiles来指定该文档块的名称。 可以在第一个文档块中使用spring.profiles.active指定激活的文档块。 4.3 激活profile一、【方式一：spring.profile.active】： 在配置文件中使用spring.profile.active来激活指定的proflie。 1spring.profile.active=dev 二、【方式二：命令行方式】： --spring.profiles.active=dev 三、【方式三：虚拟机参数】： -Dspring.profiles.active=dev]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 Spring Boot 之HelloWorld]]></title>
    <url>%2F2018%2F08%2F05%2F01%20Spring%20Boot%20%E4%B9%8BHelloWorld%2F</url>
    <content type="text"><![CDATA[1 Spring Boot 简介Spring Boot是用来简化Spring 应用的开发，约定大于配置的原则，去繁为简。Spring Boot 通过整合Spring 的整个技术栈，来完成和简化企业级的开发。 Spring Boot使用嵌入式的Servlet容器，应用无需打成war包。 Spring Boot的启动器starters，可以进行自动的依赖管理和版本控制。 Spring Boot包含了大量的自动配置。也可以修改默认值。无需配置xml，无代码生成。 Spring Boot有准生产环境的运行时应用监控。 2 微服务 Microservices简而言之，微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种小型服务都运行在自己的进程中，并与轻量级机制（通常是HTTP资源API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。 Martin Fowler关于微服务的原文： 1In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. 有篇翻译自Martin Fowler关于微服务文章的翻译，有时间可以读下：微服务。 3 开发环境JDK：1.8 maven：3.3.9 IntelliJ IDEA 2017 Spring Boot 2.x RELEASE 需要注意的是：Spring Boot 2 底层是 Spring framework 5， 必须使用jdk8以上版本，maven 3.2以上版本。 4 Spring Boot Hello World4.1 创建 Spring Boot 项目使用Spring官方的Spring Initializr。快速搭建 Spring Boot 工程。 resources文件夹的目录结构： static：保存所有的静态资源：js、css、images。 templates：保存所有的模板页面。（Spring Boot 默认是jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎（thymeleaf、freemarker）） templates目录下的文件不能直接访问，需要通过Controller做跳转。 application.properties：Spring Boot 应用的配置文件。 4.2 细节探究4.2.1 POM 文件一、【父项目】 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; Spring Boot的工程需要依赖一个父项目。我们查看这个父项目的pom文件，发现它也依赖了一个父工程： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 查看这个spring-boot-dependencies项目的pom文件，发现该pom文件里定义了Spring Boot整合的所有依赖的版本号，这就意味着，我们在自己的Spring Boot项目里引用Spring Boot整合的依赖时，不用再指定版本号。 因此，spring-boot-dependencies又被称为Spring Boot 的版本仲裁中心。 二、【导入的依赖】： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter：Spring Boot 场景启动器。 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件。 Spring Boot 将所有的功能场景都抽取出来，做成一个个starters，只需要在项目里引入这些 starter ，相关场景的所有依赖都会导入进来。版本由Spring Boot自动控制。 4.2.2 主程序类：主入口类1234567@SpringBootApplicationpublic class SpringBoot01HelloworldApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01HelloworldApplication.class, args); &#125;&#125; @SpringBootApplication：该注解标注在某个类上，说明这个类是 Spring Boot 的主配置类。Spring Boot 就应该运行这个类的main方法来启动 Spring Boot 应用。 我们查看@SpringBootApplication注解的源码，发现它是一个组合注解： 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; @SpringBootConfiguration：Spring Boot 配置类注解，标注在某个类上，表示这是一个Spring Boot 的配置类。其实查看该注解的源码，发现该注解被标注了@Configuration注解，这是 Spring 配置类的注解。 @EnableAutoConfiguration：开启自动配置功能。查看该注解的源码： 1234&gt; @AutoConfigurationPackage&gt; @Import(EnableAutoConfigurationImportSelector.class)&gt; public @interface EnableAutoConfiguration &#123;&#125;&gt; @AutoConfigurationPackage：自动配置包。作用：将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件扫描到Spring容器中。 @Import(EnableAutoConfigurationImportSelector.class)：导入自动配置类的选择器。会给容器导入自动配置类XxxAutoConfiguration。Spring Boot 在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类生效，帮我们进行自动配置工作。 自动配置都在spring-boot-autoconfigure-2.x.x.RELEASE.jar包下。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 git flow工作流]]></title>
    <url>%2F2018%2F07%2F29%2F04%20git%20flow%E5%B7%A5%E4%BD%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1 git flow 工作流 Git Flow 定义了五种分支标准： 主要分支（长期分支）： master：主分支 develop：开发分支 来源：master分支。 辅助分支： feature：功能分支 来源：develop分支。 去向：合并回develop分支，并删除该feature分支。 hotfix：热修复分支 来源：master分支。 去向：合并回master分支和develop分支，并删除该hotfix分支。 release：预发布分支 来源：develop分支。 去向：合并回master分支和develop分支，并删掉该release分支。 2 主要分支主要分支只用于与软件测试、部署、发布相关的活动，不会涉及任何的软件开发活动。主要分支会一直存在。 2.1 mastermaster分支上存放的是随时可供在生产环境中部署的代码。 它只用于新版本的发布，不涉及一切与开发、测试、部署相关的操作。 往master分支合并后，都要打上标签（Tag）。 2.2 developdevelop分支fork自master分支，主要用于开发。从develop分支拉出feature分支。新功能完成后，将feature分支合并到develop分支。 3 辅助分支辅助分支主要用于具体的软件开发工作，包括新功能的开发、Bug修复和发布前的准备工作。辅助分支不是一直存在的，当它们被合并到主要分支后，会被删除掉。 3.1 feature开发者不能直接在master分支和develop分支上做开发工作。git flow要求从develop分支上引出一条feature分支，专门做具体的开发工作。 开发完成后，把feature分支合并到develop分支上，然后把feature分支删掉。 3.2 hotfilx当线上产品遇到了严重的bug，或者紧急的缺陷。可以从master分支上拉出一条hotfix分支。问题解决后，把hotfix分支合并到master分支和develop分支。 3.3 release新功能开发完成后，代码都合并到了develop分支后，就可以为发布做准备了。但是如果这时有新的开发任务到来，或者又有新的分支需要合并，而此时的develop分支又没有准备好合并到master分支时，那么就可以从develop分支引出一条release分支作为过渡。 在release分支上，完成发布前的准备工作，如果有bug，可直接在release分支上修改并测试通过，然后合并到master分支和develop分支，最后删除release分支。 4 Merge 加上 no-ff 参数需要说明的是，Git Flow 的作者 Vincent Driessen 非常建议，合并分支的时候，加上 no-ff 参数，这个参数的意思是不要选择 Fast-Forward 合并方式，而是策略合并，策略合并会让我们多一个合并提交。这样做的好处是保证一个非常清晰的提交历史，可以看到被合并分支的存在。 1git merge --no-ff [分支名] 5 git flow 命令集git flow 对git的原生命令进行了简化来进行分支管理。 【初始化】： 1git flow init 【创建新Feature】： 1git flow feature start [分支名] 【将一个feature分支推到远程服务器】： 123git flow feature publish [分支名]或者git push origin feature/[分支名] 【完成feature】： 1git flow feature finish [分支名] 该命令会把feature/[分支名]合并到develop分支，然后删除该功能分支。 【创建release分支】： 1git flow release start [分支名] 【完成release分支】： 1git flow release finish [分支名] 该命令会把release/[分支名]合并到master分支和develop分支，并删除该release分支。 【创建一个hotfix分支】： 1git flow hotfix start [分支名] 【完成一个hotfix分支】： 1git flow hotfix finish [分支名] 该命令会把hotfix/[分支名]合并到master分支和develop分支，并删除该hotfix分支。 SourceTree支持图形化操作git flow。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 github]]></title>
    <url>%2F2018%2F07%2F28%2F03%20github%2F</url>
    <content type="text"><![CDATA[1 使用github作为远程库零、【在github上创建一个远程仓库】：略 一、【创建远程库地址别名】： [查看当前所有远程地址别名]： 1git remote -v [创建远程仓库地址别名]： 1git remote add [别名] [远程地址] 例如：git remote add origin https://github.com/liangenhao/test.git 二、【推送】： 1git push [别名] [分支名] 例如：git push origin master。推送到origin 远程仓库的master分支。 三、【克隆】： 1git clone [远程地址] 例如：git clone https://github.com/liangenhao/test.git 克隆成功后，会完整的把远程库下载到本地，并初始化本地库，并创建origin远程地址别名。 注意：在github上，团队协作需要通过成员邀请的，否则修改的内容不能推送到远程库上。 四、【拉取】： [pull]： 1git pull [远程库地址的别名] [远程分支名] 注意：pull = fetch + merge [fetch]： 1git fetch [远程库地址的别名] [远程分支名] 例如：git fetch origin master fetch操作不会修改工作区的内容。 [merge]： 1git merge [远程库地址的别名/远程分支名] 例如：git merge origin/master 五、【解决冲突】： 要点： 如果不是基于远程库的最新版所做的修改，不能直接推送（push），必须先拉去（pull）。 拉去下来后如果进入冲突状态，则按照“分支冲突解决”操作进行解决。 2 github跨团队协作一、【fork】： 首先进入别人的项目仓库，点击fork，相当于将这个仓库拷贝了一份到自己的仓库。 二、【pull request】： fork完项目后，会在自己账号的仓库中看到这个项目。并可以对这个项目进行修改和推送。 修改完成后，就可以将修改推送给源项目。 使用pull request将修改的项目推送给源项目。 原作者在源项目下就可以看到这条pull request请求。并可以对代码进行审核，查看修改的代码。 审核完成后，就可以进行合并（merge pull request）。 3 SSH 登录一、进入当前用户的家目录 $ cd ~ 二、删除.ssh 目录 $ rm -rvf .ssh 三、运行命令生成.ssh 密钥目录 $ ssh-keygen -t rsa -C atguigu2018ybuq@aliyun.com 注意： 这里-C 这个参数是大写的 C 四、进入.ssh 目录查看文件列表 $ cd .ssh $ ls -lF 五、查看 id_rsa.pub 文件内容 $ cat id_rsa.pub六、复制 id_rsa.pub 文件内容， 登录 GitHub， 点击用户头像→Settings→SSH and GPG keys、 New SSH Key 、 输入复制的密钥信息、 回到 Git bash 创建远程地址别名 git remote add origin_ssh git@github.com:atguigu2018ybuq/huashan.git 、 推送文件进行测试]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 git的基本原理]]></title>
    <url>%2F2018%2F07%2F27%2F02%20git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 哈希哈希是一个系列的加密算法。各个不同的哈希算法虽然加密强度不同， 但是有以下 几个共同点： 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果的长度固定。 哈希算法确定，输入数据确定，输出数据能够保证不变。 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大。 哈希算法不可逆。 git底层采用的是SHA-1算法。 2 git版本数据管理机制Git 把数据看作是小型文件系统的一组快照。 每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。 为了高效， 如果文件没有修改， Git 不再重新存储该文件， 而是只保留一个链接指向之前存储的文件。 所以 Git 的 工作方式可以称之为快照流。 3 git分支管理机制分支的本质就是指针。 3.1 分支的创建 3.2 分支的切换]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 git]]></title>
    <url>%2F2018%2F07%2F26%2F01%20git%2F</url>
    <content type="text"><![CDATA[1 git的结构 2 git和代码托管中心代码托管中心的作用是维护远程库。 常用的代码托管中心：gtihub、码云。 也可以自己搭建代码托管中心，例如gitlab。 3 git命令行操作3.1 本地库初始化1git init 命令git init，执行成功后会在目录下创建一个.git的文件夹，.git目录中存放的是本地库相关的文件和子目录。 3.2 设置签名【形式】： 用户名：enhao email地址：liangenhao@hotmail.com 【作用】：区分不同开发人员的身份 【辨析】：这里设置的签名和登录远程库（代码托管中心）的账号、密码没有任何关系。 【命令】： 项目级别/仓库级别：仅在当前本地库范围内有效。 12git config user.name enhaogit config user.email liangenhao@hotmail.com git会把设置好的信息存放在当前项目本地库的/.git/config文件中。 系统用户级别： 12git config --global user.name enhao_glbgit config --global user.email liangenhao_glb@hotmail.com 信息存放在系统中的.gitconfig文件中，windows系统在C:\Users\enhao目录下。linux系统在~/.gitconfig 优先级：就近原则，项目级别优先级高于系统用户级别，二者都有时，采用项目级别。 3.3 提交、查询状态【查看本地库、暂存区的状态】： 1git status 添加一个文件good.txt。使用git status命令： 12345678910On branch masterInitial commitUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) good.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 提示本地库中没有提交。但有一个未被追踪的文件：goot.txt，可以使用git add追踪这个文件（添加到暂存区）。 【将工作区的新建/修改添加到暂存区】： 1git add &lt;file&gt; 【将暂存区的内容提交到本地库】： 1git commit -m "提交信息" &lt;file&gt; 修改的文件想要提交，可以先git add，然后再git commit。获取可以直接使用git commit -a。 3.4 查看提交日志【查看提交日志】： 1git log 简洁的方式显示日志：在一行中显示 1git log --pretty=oneline 或者 1git log --oneline 这样的hash值只显示一部分。 【查看所有分支的所有操作】：包括已经被删除的commit记录和reset记录。 1git reflog 3.5 版本前进和后退【本质】：git有一个HEAD指针，对版本的前进和后退其本质就是操作这个HEAD指针的前进和后退。 一、【方式一：基于索引值操作】（推荐） 1git reset --hard 索引值 索引值是每次提交记录中的hash值。 二、【方式二：使用^符号】：只能回退。 1git reset --hard HEAD^ 每一个^符号表示回退一个版本。 三、【方式三：使用~符号】：只能回退。 如果回退的版本很多，就要写很多个^符号，这样不友好。可以使用~符号： 1git reset --hard HEAD~3 ~符号后的数字表示回退几个版本。 3.5.1 git reset 的参数--soft： 仅仅在本地库移动HEAD指针。 --mixed：（默认参数） 在本地库移动HEAD指针。 重置暂存区。 --hard：（常用 ） 在本地库移动HEAD指针。 重置暂存区。 重置工作区。 3.5.2 删除文件并找回前提：删除前，文件存在时的状态提交到了本地库。 操作：git reset --hard [指针位置/索引值] 删除操作已经提交到本地库：指针位置指向历史纪录（索引值）。 删除操作尚未提交到本地库：指针位置指向HEAD。 3.6 比较文件差异【和暂存区里的文件比较】： 1git diff &lt;file&gt; 把修改的文件git add添加到暂存区后，使用该命令比较就没有差异了。 【和本地库里某个版本文件比较】： 1git diff 指针位置/索引值 &lt;file&gt; 例如：git diff HEAD^ good.txt：和HEAD指针的上一个版本进行比较。 如果命令中不指定文件名，则比较工作区中所有的文件。 3.7 分支管理git仓库在初始化之后就会有个默认分支：master 【创建分支】： 1git branch [分支名] 【查看分支】： 1git branch -v 【切换分支】： 1git checkout [分支名] 【合并分支】： 第一步：切换到接受修改的分支上（例如：把hotfix分支合并到master分支上，则我们必须在master分支上） 1git checkout [被合并的分支名] 第二步：执行merge命令 1git merge [需要合并的分支名] 【解决冲突】： 一、冲突的表现 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADprivate String test1;private boolean flag;=======private String test2;private Integer num;&gt;&gt;&gt;&gt;&gt;&gt;&gt; e9f293eb9ce2eb9c30e6f83bf3be5faf5cc7c66e 其中： 123&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADprivate String test1;private boolean flag; 是当前分支的内容。 123private String test2;private Integer num;&gt;&gt;&gt;&gt;&gt;&gt;&gt; e9f293eb9ce2eb9c30e6f83bf3be5faf5cc7c66e 是e9f293eb9ce2eb9c30e6f83bf3be5faf5cc7c66e分支（需要合并到当前分支的分支）的内容。 二、冲突的解决 第一步：编辑文件，选择你需要的内容，删除冲突的符号。 第二步：git add [文件名] 第三步：git commit -m &quot;提交日志&quot; 注意，此时的commit操作，不能带有文件名。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 Spring 注解驱动开发之Web开发]]></title>
    <url>%2F2018%2F06%2F16%2F06%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8BWeb%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在 Servlet3.0 之前，使用web的三大组件：servlet、filter、listener都需要在web.xml中进行注册配置。 在 Servlet3.0 标准发布之后，提供了注解的支持，异步处理的支持和可插拔的插件的支持。 Tomcat7.0以上的版本才支持Servlet3.0标准。 1 Servlet3.0中ServletContainerInitializer Servlet3.0标准中引入了一个新的内容：shared libraries和runtimes pluggability。 Servlet 容器启动时会扫描当前应用里面每一个jar包的ServletContainerInitializer的实现类。 并且ServletContainerInitializer的实现类，必须绑定在META-INF/services/javax.servlet.ServletContainerInitializer。文件的内容就是ServletContainerInitializer实现类的全类名。 简单说：容器在启动应用的时候，会扫描当前应用每一个jar包里面META-INF/services/javax.servlet.ServletContainerInitializer文件中指定的实现类，启动并运行这个实现类中的方法onStartup。 ServletContainerInitializer的实现类是可以使用注解@HandlersTypes注解，作用是指定需要处理类型，容器启动的时候 将@HandlersTypes注解中指定的类型下的子类（实现类和子接口等）传递过来。 onStartup方法有两个参数： Set&lt;Class&lt;&gt;&gt; set：需要处理的类型。是@HandlersTypes注解指定的类型的子类或者子接口。 ServletContext servletContext：代表当前web应用的ServletContext对象。（一个Web应用对应一个ServletContext对象）。可以使用它来注册三大组件。 1234567891011121314@HandlesTypes(value = &#123;PersonService.class&#125;)public class MyServletContainerInitializer implements ServletContainerInitializer &#123; /** * * @param set 需要处理的类型。是@HandlersTypes注解指定的类型的子类或者子接口。 * @param servletContext 代表当前web应用的ServletContext对象。（一个Web应用对应一个ServletContext对象） * @throws ServletException */ @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123; &#125;&#125; 2 整合Spring MVC以前用xml的配置方式，需要在web.xml中先配置ContextLoaderListener监听器，来加载Spring的父容器。然后配置DispatcherServlet来配置Spring MVC前端控制器，加载子容器。 2.1 整合分析 我们可以查看spring-web-4.x.x.RELEASE包中META-INF/services/javax.servlet.ServletContainerInitializer文件里的内容： 1org.springframework.web.SpringServletContainerInitializer 这就意味着在web容器启动的时候，会加载SpringServletContainerInitializer类： 该实现类上标注了@HandlesTypes({WebApplicationInitializer.class})。则Spring应用一启动，会加载WebApplicationInitializer接口下的子类和子接口。并且为不是接口和抽象类的WebApplicationInitializer组件创建对象。 WebApplicationInitializer接口有三个抽象实现： AbstractContextLoaderInitializer：第一层抽象类，创建RootApplicationContext根容器。 AbstractDispatcherServletInitializer：第二层抽象类，创建一个web的容器。并创建一个DispatcherServlet，将创建的DispatcherServlet添加到ServletContext中。 AbstractAnnotationConfigDispatcherServletInitializer：第三层抽象类。注解方式创建根容器、创建DispatcherServlet。 【总结】：以注解方式来启动springmvc，我们自己的配置类继承AbstractAnnotationConfigDispatcherServletInitializer，并实现抽象方法，指定DispatcherServlet的配置信息。 附 spring官方文档中推荐的配置方式： 以父子容器的形式配置，web容器用来扫描Controller，视图解析器，映射等等web相关功能组件。根容器用来扫描业务逻辑组件、数据源、事务等等。 1234567891011121314151617public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; App1Config.class &#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[] &#123; "/app1/*" &#125;; &#125;&#125; 2.2 整合一、根容器配置类： 123456// Spring的根容器不扫描标注了@Controller注解的类。@ComponentScan(value = "com.enhao.spring.mvc.annotation", excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;)public class RootConfig &#123;&#125; 二、子容器配置类： 123456// spring mvc子容器只扫描标注了@Controller注解的类，警用默认的过滤规则。@ComponentScan(value = "com.enhao.spring.mvc.annotation", includeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;,useDefaultFilters = false)public class WebConfig &#123;&#125; 三、创建自定义初始化类，继承AbstractAnnotationConfigDispatcherServletInitializer抽象类： 12345678910111213141516171819202122232425262728293031// web容器启动的时候创建对象，调用方法来初始化容器以及前端控制器public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 获取根容器的配置类：类似于读取Spring的配置文件（创建出父容器） * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;RootConfig.class&#125;; &#125; /** * 获取web容器的配置类：类似于读取Spring MVC配置文件（创建出子容器） * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 获取DispatcherServlet的映射信息 * @return */ @Override protected String[] getServletMappings() &#123; // "/"：拦截所有请求，包含静态资源（xx.js, xx.png），但不包括*.jsp文件。 // "/*"：拦截所有请求，包含*.jsp return new String[]&#123;"/"&#125;; &#125;&#125; 2.3 定制SpringMVC的配置一、使用@EnableWebMvc注解，开启SpringMVC定制配置。相当于&lt;mvc:annotation-driven /&gt;。 二、配置组件：视图解析器、视图映射、静态资源映射、拦截器等等。 配置类实现WebMvcConfigurer接口，就可以配置以上提到的内容。 但实现WebMvcConfigurer接口里的方法太多了，所以我们通常继承WebMvcConfigurerAdapter抽象类，它是WebMvcConfigurer的一个空实现。 示例： 123456789101112131415161718192021@ComponentScan(value = "com.enhao.spring.mvc.annotation", excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;)@EnableWebMvcpublic class RootConfig extends WebMvcConfigurerAdapter &#123; // 配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; // 默认页面都从/WEB-INF/xxx.jsp // registry.jsp(); registry.jsp("/WEB-INF/views", ".jsp"); &#125; // 静态资源访问：相当于：&lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 3 异步请求Spring MVC的异步处理是基于Servlet3.0的异步处理。 一、方式一：控制器返回Callable： 控制器返回Callable。 SpringMVC就会异步的将Callable提交到TaskExecutor使用一个隔离的线程进行执行。 DispatcherServlet和所有的Filter退出web容器的线程，但response保持打开状态。 Callable返回结果，SpringMVC将请求重新派发给容器，恢复之前的请求。 根据DispatcherServlet返回的结果，SpringMVC继续进行视图渲染流程等（收请求-视图渲染）。 12345678910111213@ResponseBody@RequestMapping("/async01")public Callable&lt;String&gt; async01() &#123; Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return "async01"; &#125; &#125;; return callable;&#125; 二、方式二：返回DeferredResult 一旦启用了异步请求处理功能 ，控制器就可以将返回值包装在DeferredResult，控制器可以从不同的线程异步产生返回值。优点就是可以实现两个完全不相干的线程间的通信。 以创建订单为例，客户端发起请求，应用A接受到这个请求，但应用A并不处理这个请求，通过消息中间件将这个请求交给应用B处理。 首先接受到请求后，创建一个DeferredResult对象，将这个对象保存起来，并将这个对象返回，这个请求就在等待中。当另外一个线程，例如消息中间件，调用了这个对象的deferredResult.setResult()方法。请求就会得到响应。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Spring 注解驱动开发之AOP]]></title>
    <url>%2F2018%2F06%2F10%2F05%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8BAOP%2F</url>
    <content type="text"><![CDATA[1 AOP 示例 示例：编写切面用来记录日志。 123456789101112131415161718192021222324252627282930313233@Component@Aspectpublic class LogAspects &#123; //抽取公共的切入点表达式 //1、本类引用 //2、其他的切面引用 @Pointcut("execution(com.enhao.spring.annotation.service.*.*(..))") public void pointCut()&#123;&#125;; //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入） @Before("pointCut()") public void logStart(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); System.out.println(""+joinPoint.getSignature().getName()+"运行。。。@Before:参数列表是：&#123;"+Arrays.asList(args)+"&#125;"); &#125; @After("com.atguigu.aop.LogAspects.pointCut()") public void logEnd(JoinPoint joinPoint)&#123; System.out.println(""+joinPoint.getSignature().getName()+"结束。。。@After"); &#125; //JoinPoint一定要出现在参数表的第一位 @AfterReturning(value="pointCut()",returning="result") public void logReturn(JoinPoint joinPoint,Object result)&#123; System.out.println(""+joinPoint.getSignature().getName()+"正常返回。。。@AfterReturning:运行结果：&#123;"+result+"&#125;"); &#125; @AfterThrowing(value="pointCut()",throwing="exception") public void logException(JoinPoint joinPoint,Exception exception)&#123; System.out.println(""+joinPoint.getSignature().getName()+"异常。。。异常信息：&#123;"+exception+"&#125;"); &#125;&#125; @Aspect注解告知标注的类是切面类。 开启基于注解的AOP模式：（这个一定要加的） 一、在xml配置方式中： 1&lt;aop:aspectj-autoproxy /&gt; 二、使用注解的配置方式，在配置类上标注@EnableAspectJAutoProxy注解。 1234@Configuration@EnableAspectJAutoProxypublic class MainConfigOfAOP &#123;&#125; 2 声明式事务示例一、【需要导入的相关依赖】： 包括：数据源、数据库驱动、Spring-jdbc。 二、【配置数据源】： JdbcTemplate：Spring提供的简化数据库操作的工具。 12345678910111213141516171819@Configurationpublic class TxConfig &#123; @Bean public DataSource dataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser("root"); dataSource.setPassword("root"); dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test"); return dataSource; &#125; @Bean public JdbcTemplate jdbcTemplate() throws PropertyVetoException &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125;&#125; 三、【编写Dao和Service】： 12345678910111213141516171819202122232425@Repositorypublic class PersonDaoImpl implements PersonDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void insert() &#123; String sql = "insert into person (name, age) value (?, ?)"; jdbcTemplate.update(sql, "enhao", 18); &#125;&#125;@Service("personService")public class PersonServiceImpl implements PersonService &#123; @Autowired private PersonDao personDao; @Transactional @Override public void insert() &#123; personDao.insert(); &#125;&#125; 在Service层给方法加上事务。 四、【开启注解的事务支持】： 在配置类上标注：@EnableTransactionManagement。等价于xml配置：&lt;tx:annotation-driven /&gt;。 在配置类中配置事务管理器transactionManager： 1234567891011121314151617181920212223242526@EnableTransactionManagement // 开启注解事务支持@ComponentScan("com.enhao.spring.annotation")@Configurationpublic class TxConfig &#123; @Bean public DataSource dataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser("root"); dataSource.setPassword("root"); dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test"); return dataSource; &#125; @Bean public JdbcTemplate jdbcTemplate() throws PropertyVetoException &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean // 配置事务管理器 public PlatformTransactionManager transactionManager() throws PropertyVetoException &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Spring 注解驱动开发之自动装配]]></title>
    <url>%2F2018%2F06%2F03%2F04%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[何为自动装配：Spring 利用依赖注入（DI），完成对容器中对各个组件的依赖关系的赋值。 1 @Autowired、@Qualifier、@Primary@Autowired：Spring 定义的注解。 默认优先按照类型去容器中找对应的组件Bean。找到就赋值。 如果找到多个相同类型的组件Bean，再将属性名称作为组件的id去容器中查找。 有属性required，默认值为true，即必须的，意思为必须装配这个Bean。如果为false，非必须的，表示如果容器中没有这个Bean，就不装配。 @Qualifier：和@Autowired组合使用，用来指定需要装配的组件Bean的id，而不是使用属性名。 @Primary：让Spring进行自动装配的时候，默认使用首选的Bean： 123456789@Configurationpublic class MainConfigOfAutowired &#123; @Primary @Bean public PersonService personService() &#123; return new PersonServiceImpl(); &#125;&#125; 若有多个类型相同的Bean，这样使用@Autowired自动装配的时候，默认使用的就是加了@Primary的Bean。若想执行其他的Bean就要使用@Qualifier。 2 @Resource、@Inject@Resource和@Inject都是java规范的注解。 @Resource：默认按照组件Bean的名称自动装配。可以使用属性name执行组件的名称。 注意：@Resource不支持@Primary注解的功能。 @Inject：和@Autowired功能一样，同样支持@Primary注解的功能。 注意：@Inject需要额外引入javax.inject的依赖。 3 方法、构造器位置的自动装配@Autowired注解不仅可以标注在属性上，还可以标注在构造器、参数、方法上。 一、【标注在方法位置】：@Autowired标注在方法上时，容器创建对象时，就会调用方法完成赋值。方法使用的参数，自定义类型的值会从容器中获取 1234@Autowiredpublic void setCar(Car car) &#123; // Car对象从容器中获取 this.car = car;&#125; 二、【标注在构造器位置】： 容器加载组件时，默认会调用无参构造器创建对象。 若在有参构造器上标注@Autowired注解，创建对象时会调用该有参构造器，构造器的参数从容器中获取。 1234@Autowiredpublic Person(Car car) &#123; this.car = car;&#125; 注意：如果组件Bean只有唯一的一个有参构造器，该构造器的@Autowired可以省略。参数还是可以从容器中获取。 三、【标注在参数位置】： 1234567public void setCar(@Autowired Car car) &#123; // Car对象从容器中获取 this.car = car;&#125;public Person(@Autowired Car car) &#123; this.car = car;&#125; 标注在参数上和标注在方法上效果一样。 如果采用@Bean的方式注入Bean，有参构造的参数该怎么赋值： 1234@Beanpublic Person person(Car car) &#123; return new Person(car);&#125; 可以注解在注入Bean的方法的形参上加上构造的参数。 4 Aware注入Spring底层组件如果我们自己定义的组件Bean想使用Spring容器底层的一些组件，例如：ApplicationContext、BeanFactory等等。可以让自定义的组件实现XxxAware接口，就可以将Spring容器的一些组件注入到我们自定义的组件中。 示例： 1234567891011121314151617public class Pig implements ApplicationContextAware, BeanNameAware,EmbeddedValueResolverAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Override public void setBeanName(String name) &#123; &#125; @Override public void setEmbeddedValueResolver(StringValueResolver resolver) &#123; &#125;&#125; 实现ApplicationContextAware接口并重写setApplicationContext方法，就可以将ApplicationContext对象传入组件Bean中。 实现BeanNameAware接口并重写setBeanName方法，就可以获取到容器为当前Bean起的名称。 实现EmbeddedValueResolverAware接口并重写setEmbeddedValueResolver方法，就可以获取到StringValueResolver值解析器，就可以用来解析#{}和${}。 XxxAware的原理是由XxxProcessor后置处理器来实现的，每个Aware都会对应一个后置处理器。 5 @ProfileProfile：可以根据当前环境，动态的激活或切换一系列组件的功能。 以数据源为例，在开发环境、测试环境和生产环境中，数据源的配置都不一样，在不更改代码的情况下，动态的切换这三种环境，就需要使用Profile。 @Profile：指定组件在哪个环境的情况下才能被注册到容器中。默认时default。 一、在配置类中注入三种不同环境的数据源 123456789101112131415161718192021222324252627282930313233343536@Configurationpublic class MainConfigOfProfile &#123; @Profile("test") @Bean public DataSource dataSourceTest() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser("root"); dataSource.setPassword("root"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/springtest"); dataSource.setDriverClass("com.mysql.jdbc.Driver"); return dataSource; &#125; @Profile("dev") @Bean public DataSource dataSourceDev() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser("root"); dataSource.setPassword("root"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/crm"); dataSource.setDriverClass("com.mysql.jdbc.Driver"); return dataSource; &#125; @Profile("prod") @Bean public DataSource dataSourceProd() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser("root"); dataSource.setPassword("root"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/leh_test"); dataSource.setDriverClass("com.mysql.jdbc.Driver"); return dataSource; &#125;&#125; 使用@Profile注解指定在哪种环境下会被注入。 二、指定不同的环境 方式一：使用命令行动态参数：-Dspring.profiles.active=test 方式二：代码的方式激活： 12345678// 创建applicationContext对象AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();// 设置需要激活的环境applicationContext.getEnvironment().setActiveProfiles("test");// 注册配置类applicationContext.register(MainConfigOfProfile.class);// 启动刷新容器applicationContext.refresh(); @Profile不仅可以写在方法上，还可以写在类上，写在类上，只有指定的环境，整个配置类里的所有配置才会生效。 没有标注@Profile的bean在任何环境都会加载。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Spring 注解驱动开发之属性赋值]]></title>
    <url>%2F2018%2F05%2F31%2F03%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1 @Value 赋值和 @PropertySource 加载属性文件@Value注解的唯一属性value用来赋值。 @PropertySource注解用来加载属性文件。使用${}可以取出配置文件里的值。 一、【基本数值】： 12@Value("张三")private String name; 二、【SpELl 表达式赋值：#{}】： 12@Value("#&#123;100-2&#125;")private Integer age; 三、【取配置文件(properties)中的值进行赋值：${}】： 首先创建person.properties配置文件： 1person.nickName=咿呀咿呀呦 在spring配置文件中加载配置文件： 1&lt;context:property-placeholder location="classpath:person.properties"/&gt; 或者，在配置类中使用@PropertySource加载配置文件： 12345678@Configuration@PropertySource(value = &#123;"classpath:person.properties"&#125;)public class MainConfigOfPropertyValues &#123; @Bean public Person person() &#123; return new Person(); &#125;&#125; @PropertySource的value属性的值是数组，这就意味着可以加载多个配置文件。又因为该注解是重复注解，所以也可以多次使用该注解加载不同的配置文件。还可以使用@PropertySources注解，该注解的value属性可以加载多个@PropertySource注解。 类路径下的文件使用classpath:标注。文件路径下的文件使用file:标注。 使用@Value赋值： 12@Value("$&#123;person.nickName&#125;")private String nickName; 【注】：Spring 中 #{}和${}的区别： ${key}通常用来获取属性文件中的内容。 #{表达式}是SpEL表达式的格式。 二者可以混合使用：#{&#39;${key}&#39;}]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0102 Spring 注解驱动开发之Bean的生命周期]]></title>
    <url>%2F2018%2F05%2F29%2F02%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Bean的生命周期：创建 -&gt; 初始化 -&gt; 销毁 的过程。Bean的生命周期由Spring 容器管理 。我们可以自定义Bean的初始化和销毁方法，容器在Bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法。 Bean创建：Bean创建的时候，单实例Bean是在容器启动的时候创建，多实例Bean是在每次获取的时候创建对象。 Bean初始化：对象创建完成，并赋值好后，调用初始化方法。 Bean销毁：单实例Bean是在Spring容器关闭的时候调用销毁的方法。多实例Bean，Spring容器是不会调用销毁方法。我们可以手动调用销毁方法。 由五种定义初始化和销毁方法的方式： 方式一：在使用xml配置方式的时候，我们可以在&lt;bean&gt;标签中指定init-method和destroy-method两个属性来指定初始化和销毁方法，初始化和销毁方法不能有参数，但可以抛出异常。 方式二：使用@Bean指定初始化和销毁方法。 方式三：让Bean实现InitializingBean和DisposableBean接口 方式四：使用JSR250规范里的@PostConstruct和@PreDestroy注解。 方式五：使用Bean的后置处理器BeanPostProcessor。 后置处理器的作用：在Bean初始化前后进行一些处理操作。 1 @Bean指定初始化和销毁方法@Bean注解由两个属性：initMethod和destroyMethod。通过这两个方法来指定初始化和销毁方法。 一、有一个Bean如下： 1234567891011121314public class Car &#123; public Car() &#123; System.out.println("this is Car Constructor method"); &#125; public void init() &#123; System.out.println("this is Car init method"); &#125; public void destroy() &#123; System.out.println("this is Car destroy method"); &#125;&#125; 二、配置类如下，在配置类中我们注入了Car这个Bean，并使用@Bean注解指定了这个Bean的初始化和销毁方法。 1234567@Configurationpublic class ManiConfigOfLifeCycle &#123; @Bean(initMethod = "init", destroyMethod = "destroy") public Car car() &#123; return new Car(); &#125;&#125; 2 Bean实现InitializingBean和DisposableBean接口 让Bean实现InitializingBean接口，并重写初始化方法afterPropertiesSet。该方法会在Bean创建完成，并属性都赋值完成后调用。 让Bean实现DisposableBean接口，并重写销毁方法destroy。单实例Bean，该方法在容器关闭的时候调用。 示例： 12345678910111213141516@Componentpublic class Cat implements InitializingBean, DisposableBean &#123; public Cat() &#123; System.out.println("this is Car constructor method"); &#125; @Override public void destroy() throws Exception &#123; System.out.println("this is Car destroy method"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("this is Car init method"); &#125;&#125; 配置类中使用包扫描注入该Bean。 3 使用@PostConstruct和@PreDestroy注解@PostConstruct：在Bean创建完成，并且属性赋值完成后，来执行初始化方法。 @PreDestroy：在容器销毁Bean之前，来执行销毁方法。 注意：@PostConstruct和@PreDestroy都是只能标注在方法上的注解。 示例： 1234567891011121314151617@Componentpublic class Dog &#123; public Dog() &#123; System.out.println("this is Dog constructor method"); &#125; @PostConstruct public void init() &#123; System.out.println("this is Dog init method"); &#125; @PreDestroy public void destroy() &#123; System.out.println("this is Dog destroy method"); &#125;&#125; 配置类中使用包扫描注入该Bean。 4、使用后置处理器BeanPostProcessor4.1 BeanPostProcessor的示例后置处理器BeanPostProcessor是一个接口，它有两个方法：postProcessBeforeInitialization和postProcessAfterInitialization。 postProcessBeforeInitialization：在创建Bean实例，对Bean的属性赋值，并在任何初始化方法调用之前执行，例如实现InitializingBean接口的afterPropertiesSet方法，或者是自定义的init-method方法。 12&gt; 原文：Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean initialization callbacks (like InitializingBean&apos;s &#123;@code afterPropertiesSet&#125; or a custom init-method).&gt; postProcessAfterInitialization：在初始化方法调用之后执行。 12&gt; 原文：Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean initialization callbacks (like InitializingBean&apos;s &#123;@code afterPropertiesSet&#125; or a custom init-method). &gt; 一、定义自己的后置处理器 123456789101112131415@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization" + bean + " " + beanName); // 返回值可以是原来的bean，也可以是一个包装的bean return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessAfterInitialization" + bean + " " + beanName); return bean; &#125;&#125; 执行顺序：构造方法 -&gt; 后置处理器的前置处理 -&gt; afterPropertiesSet/@PostConstruct -&gt; 后置处理器的后置处理。 简而言之，在 初始化方法执行之前执行postProcessBeforeInitialization，在初始化方法执行之后执行postProcessAfterInitialization。若没有自定义初始化方法，后置处理器也是会执行的。 4.2 BeanPostProcessor的原理通过查看Spring源码，AbstractAutowireCapableBeanFactory类中有一个initializeBean方法，该方法中调用了invokeInitMethods方法，用来执行初始化方法(afterPropertiesSet或自定义初始化方法)。在调用了invokeInitMethods方法前调用了applyBeanPostProcessorsBeforeInitialization方法，在调用了invokeInitMethods方法后调用了applyBeanPostProcessorsAfterInitialization方法。 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125;// 后置处理器的前置处理@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; // 遍历得到容器中的所有的BeanPostProcessor，挨个执行，如果一旦方法返回null，后面的BeanPostProcessor就不会执行了。 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 在执行initializeBean之前执行了populateBean方法，对bean属性进行赋值。 4.3 BeanPostProcessor在Spring底层的使用以几个BeanPostProcessor的实现类为例： 4.3.1 ApplicationContextAwareProcessor一、【作用】：是可以向组件中注入IOC容器。 二、【使用】： 例如有一个组件Pig，实现ApplicationContextAware接口，重写接口中的setApplicationContext方法。 123456789public class Pig implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 这样就把容器注入到组件中了。 三、【原理】： 通过查看ApplicationContextAwareProcessor中的postProcessBeforeInitialization方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ApplicationContextAwareProcessor implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123; AccessControlContext acc = null; if (System.getSecurityManager() != null &amp;&amp; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123; acc = this.applicationContext.getBeanFactory().getAccessControlContext(); &#125; if (acc != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; ApplicationContextAwareProcessor.this.invokeAwareInterfaces(bean); return null; &#125; &#125;, acc); &#125; else &#123; this.invokeAwareInterfaces(bean); &#125; return bean; &#125;&#125;private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware)bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; 以我们这个为例，在bean执行初始化之前，先判断这个bean是否实现了ApplicationContextAware，如果是，则调用invokeAwareInterfaces，向bean中注入值。 如果是ApplicationContextAware，就将applicationContext注入。 4.3.2 InitDestroyAnnotationBeanPostProcessor一、【作用】：用来处理@PostConstruct和@PreDestroy注解的。这就是为什么标注了这两个注解的方法称为生命周期方法的原因。 二、【原理】： 1234567891011121314151617public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()); try &#123; metadata.invokeInitMethods(bean, beanName); &#125; catch (InvocationTargetException ex) &#123; throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException()); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, "Failed to invoke init method", ex); &#125; return bean; &#125;&#125; 4.3.3 AutowiredAnnotationBeanPostProcessor【作用】：用来处理@Autowired注解，这就是为什么标注的@AutoWired注解的属性可以进行依赖注入的原因。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 Spring 注解驱动开发之Spring容器注入]]></title>
    <url>%2F2018%2F05%2F27%2F01%20Spring%20%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8BSpring%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在我们使用传统的 Spring MVC + Spring + Mybatis 整合开发时，通常采用的是使用xml配置 + Java注解混合式的开发，即跟业务相关的使用Java注解，配置相关的使用xml文件。这就造成了我们需要写大量的xml配置代码。 在微服务兴起后，Spring Boot 和 Spring Cloud 等微服务框架都摒弃了xml配置文件的配置方式，大量使用Java注解来进行开发。 Spring 注解驱动开发分为Spring 容器相关，Spring 原理，Spring MVC。 首先从Spring容器说起，Spring容器的两个重要概念就是控制反转和依赖注入。Spring将所有的组件都放在了容器中，组件中的关系通过容器来进行自动装配。那如何使用注解的形式进行容器的注入和自动装配？ 1 组件注册1.1 注入Bean：@Configuration、@Bean1.1.1 xml配置方式最原始的配置方式，需要将注入的Bean全都配置到Spring的配置文件中。 首先，我们有一个bean对象。 12345public class Persion &#123; private String name; private Integer age; // getter,setter,construction,toString&#125; 要想将这个Bean对象注入到Spring容器中，如下： 一、在Spring的配置文件 applicationContext.xml 配置文件中配置bean： 1234&lt;bean id="person" class="com.enhao.spring.annotation.bean.Person"&gt; &lt;property name="name" value="enhao"/&gt; &lt;property name="age" value="18"/&gt;&lt;/bean&gt; 二、测试 12345public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); Person person = (Person) applicationContext.getBean("person"); System.out.println(person);&#125; 使用ClassPathXmlApplicationContext读取配置文件。 1.1.2 注解驱动配置方式注解驱动开发将不再使用applicationContext.xmlxml配置文件，使用Java类取代配置文件。 一、配置类等同于之前的配置文件。在配置类上使用@Configuration注解，表明这是一个配置类。 注入对象时，使用@Bean注解，给容器中注册一个Bean。方法返回值为Bean的类型，方法名为Bean的id。也可以使用@Bean注解的value属性设置id。 123456789// 配置类 == 配置文件@Configurationpublic class MainConfig &#123; @Bean public Person person() &#123; return new Person("enhao", 18); &#125;&#125; @Bean注解，等价于1.1中的&lt;bean&gt;&lt;/bean&gt;配置方式。 二、测试： 12345public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); Person person = (Person) applicationContext.getBean("person"); System.out.println(person);&#125; 使用AnnotationConfigApplicationContext读取配置类。不再是ClassPathXmlApplicationContext了。 1.2 包扫描：@ComponentScan1.2.1 xml + 注解混合配置方式在Java5引入注解的特性后，诞生了xml + 注解混合式开发的方式。 一、在Spring的配置文件 applicationContext.xml 配置文件中开启注解扫描： 1&lt;context:component-scan base-package="com.enhao.spring.annotation.service"/&gt; 主要标注了@controller、@Service、@Repository、@Component注解中任意一个，都会被扫描自动注入容器中。 二、在需要注入的Bean类上添加@Component注解： 1234567@Service("personService")public class PersonServiceImpl implements PersonService &#123; @Override public void show() &#123; System.out.println("this is personServiceImpl bean"); &#125;&#125; 三、测试： 12345public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); PersonService personService = (PersonService) applicationContext.getBean("personService"); personService.show();&#125; 1.2.2 注解驱动配置方式一、注解驱动的配置包扫描的方式是直接在配置类上使用@ComponentScan注解即可。 12345@Configuration@ComponentScan(&#123;"com.enhao.spring.annotation"&#125;)public class MainConfig &#123; &#125; 二、在需要注入的Bean类上添加@controller、@Service、@Repository、@Component注解中任意一个即可。 @ComponentScan的属性： value：指定要扫描的包。 excludeFilters：指定扫描的时候按照什么规则排除哪些组件。值是Filter[]。 @Filter注解：type属性表示指定排除的规则：按照注解排除，按照AspectJ表达式排除，按照给定的类型排除、按照自定义排除和按照正则排除；classes属性表示根据排除规则需要排除的类。 includeFilters：指定扫描的时候只需要包含哪些组件。值为Filter[]。注意：如果使用includeFilters，必须关闭默认的过滤规则(默认过滤规则是包含所有)，将useDefaultFilters设置为false。 123@ComponentScan(value = "com.enhao.spring.annotation", excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class, Service.class&#125;)&#125;) FilterType.ANNOTATION使用按照注解排除的规则，排除标注了@Controller和@Service注解的Bean。 123@ComponentScan(value = "com.enhao.spring.annotation", useDefaultFilters = false, includeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;) 使用按照注解的规则，只包含使用了@Controller注解的Bean。 注意：使用includeFilters时，必须将useDefaultFilters的值设置为false。 1234@ComponentScan(value = "com.enhao.spring.annotation", useDefaultFilters = false, includeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;), @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;PersonService.class&#125;)&#125;) FilterType.ASSIGNABLE_TYPE包含给定的类型，这里会包含是PersonService类型的Bean。 由于java8引入了重复注解的概念（具体可以查看Java8新特性），所有可以写多个@ComponentScan注解来指定不同的规则。 如果是Java8以前的版本，可以使用@ComponentScans注解，该注解里可以写多个@ComponentScan注解。 1.3 作用域：@Scope1.3.1 @Scope和@Bean一起使用Spring 的Bean默认都是单实例的。可用使用@Scope来指定Bean的作用域。 通过@Scope注解的value属性来指定Bean的作用域，值有四种：singleton(默认值)、prototype、request、session。 12345678@Configurationpublic class ScopeConfig &#123; @Bean @Scope("prototype") public Person person2() &#123; return new Person("enhao", 19); &#125;&#125; 等同于&lt;bean scope=&quot;&quot;&gt;&lt;/bean&gt; 注意： 在默认单实例时，在Spring容器启动时就会调用方法将Bean对象放到容器中。以后每次获取都是直接从容器中获取的。 在多实例时，Spring 容器启动时并不会区创建多实例Bean的对象。多实例Bean对象是在调用的时候才放到容器中的，而且是每调用一次就向容器中放入一个对象。 1.3.2 @Scope和@Component一起使用在使用包扫描的时候，如果要指定Bean的作用域，可以和@Component、@Service、@Repository、@Controller等注解一起使用，使用方式和上面一样。 1.4 懒加载：@Lazy 懒加载只针对于单实例的Bean。因为单实例的Bean是在容器启动的时候就加载的。 懒加载：容器启动的时候不创建对象。在第一次使用（获取）Bean的时候创建对象，并初始化。 1.4.1 @Lazy和@Bean一起使用12345678@Configurationpublic class ScopeConfig &#123; @Bean @Lazy public Person person2() &#123; return new Person("enhao", 19); &#125;&#125; 1.4.2 @Lazy和@Component一起使用在使用包扫描的时候，如果要指定Bean的懒加载，可以和@Component、@Service、@Repository、@Controller等注解一起使用，使用方式和上面一样。 1.5 条件注解：@Conditional作用：按照一定的条件进行判断，满足条件给容器注册Bean。 @Conditional注解的value属性是继承了Condition的Class对象。因此需要实现Condition接口。 例子：判断当前的系统，如果是linux系统，则创建Persion3对象。如果是Windows系统则创建Person4对象。 12345678910111213141516171819202122232425262728293031323334353637383940// 判断是否是windows系统public class WindowsCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment environment = conditionContext.getEnvironment(); String osName = environment.getProperty("os.name"); if (osName.contains("Windows")) &#123; return true; &#125; return false; &#125;&#125;// 判断是否是linux系统public class LinuxCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment environment = conditionContext.getEnvironment(); String osName = environment.getProperty("os.name"); if (osName.contains("linux")) &#123; return true; &#125; return false; &#125;&#125;// 配置类@Configurationpublic class ScopeConfig &#123; @Conditional(LinuxCondition.class) @Bean public Person person3() &#123; return new Person("enhao1", 20); &#125; @Conditional(WindowsCondition.class) @Bean public Person person4() &#123; return new Person("enhao2", 21); &#125;&#125; 1.6 快速注册组件：@Import1.6.1 直接导入配置类或普通类@Import注解支持导入配置类，也支持导入普通的java类，并将其声明成一个bean。 1234@Configuration@Import(&#123;Color.class&#125;)public class MainConfig2 &#123;&#125; 注入Bean的id默认是组件的全类名。 1.6.2 使用ImportSelector使用ImportSelector导入选择器接口。接口里的selectImports方法的返回值返回的是需要导入的组件的全类名数组。 一、自定义导入选择器： 1234567891011public class MyImportSelector implements ImportSelector &#123; // 参数AnnotationMetadata：当前标注@Import注解的类的所有注解信息 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; // 返回值不要返回null，否则会报空指针异常。 return new String[]&#123;"com.enhao.spring.annotation.bean.Blue", "com.enhao.spring.annotation.bean.Yellow"&#125;; &#125;&#125; 二、在@Import注解中引入自定义的导入选择器。 1234@Configuration@Import(&#123;Color.class, MyImportSelector.class&#125;)public class MainConfig2 &#123;&#125; 1.6.3 使用ImportBeanDefinitionRegistrar使用ImportBeanDefinitionRegistrar接口，实现registerBeanDefinitions方法，在容器中自己添加组件。 一、自定义一个ImportBeanDefinitionRegistrar实现类： 123456789101112131415161718public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * 把所需要添加到容器中的bean，通过BeanDefinitionRegistry注册进来 * @param annotationMetadata 当前标注@Import注解的类的所有注解信息 * @param beanDefinitionRegistry BeanDefinitionRegistry Bean定义的注册类 */ @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; boolean blue = beanDefinitionRegistry.containsBeanDefinition("com.enhao.spring.annotation.bean.Blue"); boolean yellow = beanDefinitionRegistry.containsBeanDefinition("com.enhao.spring.annotation.bean.Yellow"); if (blue &amp;&amp; yellow) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(Rainbow.class); // 注册bean beanDefinitionRegistry.registerBeanDefinition("rainbow", beanDefinition); &#125; &#125;&#125; 二、在@Import中使用 123@Configuration@Import(&#123;MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)public class ScopeConfig &#123;&#125; 1.7 使用FactoryBean注册组件一、自定义一个FactoryBean实现类： 123456789101112131415161718192021222324252627282930public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; /** * * @return 返回一个Color对象，这个对象会添加到容器中 * @throws Exception */ @Override public Color getObject() throws Exception &#123; System.out.println("this is a color factory bean"); return new Color(); &#125; /** * * @return 返回对象类型 */ @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; /** * 是单例吗 * @return true - 是单例模式 false - 是多例模式 */ @Override public boolean isSingleton() &#123; return true; &#125;&#125; 二、在配置类中配置工厂类Bean： 1234@Beanpublic ColorFactoryBean colorFactoryBean() &#123; return new ColorFactoryBean();&#125; 默认获取到的是工厂Bean调用GetObject创建的对象，这里是Color。 要获取工厂Bean的本身，我们需要给id前面加一个&amp;标识。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 Java8新特性之重复注解和类型注解]]></title>
    <url>%2F2018%2F05%2F13%2F06%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1 重复注解重复注解：允许在同一声明类型（类，属性，或方法）上多次使用同一个注解。重复注解本身必须使用@Repeatable注解。 一、步骤一：自定义注解MyAnnotation和包装类注解MyAnnotations，包装类注解用来放置一组具体的MyAnnotation注解： 123456789101112@Repeatable(MyAnnotations.class)@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "enhao";&#125;@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations &#123; MyAnnotation[] value();&#125; 二、使用注解： 123456public class TestAnnotation &#123; @MyAnnotation("hello") @MyAnnotation("World") public void show() &#123; &#125;&#125; 测试： 123456789@Testpublic void test1() throws NoSuchMethodException &#123; Class&lt;TestAnnotation&gt; clazz = TestAnnotation.class; Method method = clazz.getMethod("show"); MyAnnotation[] annotations = method.getAnnotationsByType(MyAnnotation.class); for (MyAnnotation myAnnotation : annotations) &#123; System.out.println(myAnnotation.value()); &#125;&#125; 可以获取show方法上注解的两个值。 2 类型注解Java 8的类型注解扩展了注解使用的范围。新增ElementType.TYPE_USE和ElementType.TYPE_PARAMETER。（在@Target注解上） ElementType.TYPE_USE表示该注解能写在使用类型的任何语言中，如声明语句、泛型和强制转换语句中的类型。 ElementType.TYPE_PARAMETER表示该注解能写在类型变量的声明语句中。 1234//初始化对象时 String myString = new @NotNull String(); //对象类型转化时 myString = (@NonNull String) str; 2.1 类型注解的作用引用 扩展注解 中的内容： 类型注解被用来支持在java中做强类型检查。配合第三方工具 Checker Framework。可以在编译的时候检测出runtime error（UnsupportedOperationException； NumberFormatException；NullPointerException异常等都是runtime error)。 注意：java 5,6,7版本是不支持注解@NonNull，但checker framework 有个向下兼容的解决方案，就是将类型注解@NonNull 用/**/注释起来。 这样javac编译器就会忽略掉注释块，但用checker framework里面的javac编译器同样能够检测出@NonNull错误。通过 类型注解 + checker framework 可以在编译时就找到runtime error。]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Java8新特性之时间日期API]]></title>
    <url>%2F2018%2F05%2F13%2F05%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI%2F</url>
    <content type="text"><![CDATA[Java8包含了全新的时间日期API，这些功能都放在了java.time包下。这套全新的时间日期API是不可变且线程安全的（This class is immutable and thread-safe）。 1 本地时间：LocalDate、LocalTime、LocalDateTimelocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或者时间，并不包含当前的时间信息。也不包含与时区相关的信息。 localDate、LocalTime、LocalDateTime三个的使用的方式一模一样。 以localDateTime为例： 123456789101112// 获取当前日期时间LocalDateTime nowDateTime = LocalDateTime.now();System.out.println(nowDateTime);// 获取指定的日期时间LocalDateTime assignDateTime = LocalDateTime.of(2017, 11, 22, 15, 23, 55);System.out.println(assignDateTime);// 当前时间加两年LocalDateTime nowDateTimePlus2Years = nowDateTime.plusYears(2);System.out.println(nowDateTimePlus2Years);// 当前时间减两年LocalDateTime nowDateTimeMinus2Years = nowDateTime.minusYears(2);System.out.println(nowDateTimeMinus2Years); 输出结果： 2018-05-13T16:56:04.3462017-11-22T15:23:552020-05-13T16:56:04.3462016-05-13T16:56:04.346 2 时间戳：InstantInstant：时间戳，以1970年1月1日00:00:00 开始，到某个时间的毫秒值。 12345678910111213// 默认获取UTC时区（UTC：世界统一时间）Instant instant1 = Instant.now();System.out.println(instant1);// 获取时间戳long milli = instant1.toEpochMilli();System.out.println(milli);// 带偏移量运算：偏移8小时：北京时间OffsetDateTime offsetDateTime = instant1.atOffset(ZoneOffset.ofHours(8));System.out.println(offsetDateTime);// 时间戳加60秒Instant instant2 = Instant.ofEpochSecond(60);System.out.println(instant2); 输出结果： 2018-05-13T11:54:33.717Z15262124737172018-05-13T19:54:33.717+08:001970-01-01T00:01:00Z 3 计算间隔：Duration、PeriodDuration：计算两个“时间”之间的间隔。 Period：计算两个“日期”之间的间隔。 计算两个“时间”之间的间隔。 123456789101112131415161718192021Instant instant1 = Instant.now();try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;Instant instant2 = Instant.now();Duration duration = Duration.between(instant1, instant2);System.out.println(duration.toMillis());System.out.println("==================");LocalTime time1 = LocalTime.now();try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;LocalTime time2 = LocalTime.now();System.out.println(Duration.between(time1, time2).toMillis()); 计算两个“日期”之间的间隔。 123456LocalDate date1 = LocalDate.of(2017, 1, 1);LocalDate date2 = LocalDate.now();Period period = Period.between(date1, date2);System.out.println(period.getYears());System.out.println(period.getMonths());System.out.println(period.getDays()); 1412 相差1年4个月12天。 5 时间校正器：TemporalAdjusterTemporalAdjuster：时间校正器，有时我们可能会需要获取例如：将日期调整到“下个周如”等操作。 TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。 例如： 1234567891011121314151617181920LocalDateTime dateTime = LocalDateTime.now();// 指定日期LocalDateTime dateTimeWithDayOfMonth = dateTime.withDayOfMonth(10);// 使用时间校正器指定时间：下一个周末LocalDateTime dateTimeNextSunday = dateTime.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));System.out.println(dateTimeNextSunday);// 自定义时间校正器：获取下一个工作日LocalDateTime dateTime1 = dateTime.with((temporal) -&gt; &#123; LocalDateTime time = (LocalDateTime)temporal; DayOfWeek dayOfWeek = time.getDayOfWeek(); if (dayOfWeek.equals(DayOfWeek.FRIDAY)) &#123; return time.plusDays(3); &#125; else if (dayOfWeek.equals(DayOfWeek.SATURDAY)) &#123; return time.plusDays(2); &#125; else &#123; return time.plusDays(1); &#125;&#125;);System.out.println(dateTime1); 6 时间日期格式化：dateTimeFormatter12345678910111213// 使用ISO标准日期格式DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;LocalDateTime dateTime = LocalDateTime.now();// LocalDateTime的格式化方法String dateStr = dateTime.format(formatter);System.out.println(dateStr);// 使用自定义日期格式DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");// DateTimeFormatter的格式化方法String dateStr2 = formatter1.format(dateTime);System.out.println(dateStr2); 7 时区的处理：ZonedDate、ZonedTime、ZonedDateTime 以LocalDateTime为例。 使用LocalDateTime的static LocalDateTime now(ZoneId zone)方法来指定时区： 1LocalDateTime dateTime = LocalDateTime.now(ZoneId.of("America/Los_Angeles")); 结果：2018-05-13T06:24:47.349。显示的是美国洛杉矶时区的时间。 使用LocalDateTime的ZonedDateTime atZone(ZoneId zone)方法转换成ZonedDateTime（带时区的时间日期对象）： 123LocalDateTime dateTime2 = LocalDateTime.now();ZonedDateTime zonedDateTime = dateTime2.atZone(ZoneId.of("America/Los_Angeles"));System.out.println(zonedDateTime); 结果：2018-05-13T06:24:47.446-07:00[America/Los_Angeles] ZonedDateTime是带时区的时间日期。]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>时间日期API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Java8新特性之接口中的默认方法与静态方法]]></title>
    <url>%2F2018%2F05%2F05%2F04%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Java8之前，接口中可以包含的成员有：抽象方法和常量。抽象方法的默认修饰是public abstract。常量的默认修饰是public static final。并且这些默认修饰符是可以省略不写的。 在Java8中接口可以包含具有具体实现的方法。有默认方法和静态方法两种。 1 接口中的默认方法默认方法，使用default修饰符。default不可省略。 1.1 “类优先”原则若一个接口中定义了默认方法。而另外一个父类或者接口中又定义了一个同名的方法时： 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法）， 那么必须覆盖该方法来解决冲突 。 一、接口中定义了默认方法，父类中也又相同名称和参数的方法： 1234567891011121314151617// 接口中定义了一个默认方法public interface MyInterface &#123; default String getName() &#123; return "this is my interface!"; &#125;&#125;// 父类中有一个和接口中的默认方法同名同参数的方法public class SuperClass &#123; public String getName() &#123; return "this is super class!"; &#125;&#125;// 子类同时继承父类和实现接口，使用的是父类中的方法，接口中的默认方法会被忽略public class SubClass extends SuperClass implements MyInterface &#123; &#125; 二、一个接口中定义了一个默认方法，另一个接口中也定义了一个同名同参数的方法 12345678910111213// 接口中定义了一个默认方法public interface MyInterface &#123; default String getName() &#123; return "this is my interface!"; &#125;&#125;// 另一个接口中定义了一个同名同参数的默认方法public interface MyOtherInterface &#123; default String getName() &#123; return "this is my other interface!"; &#125;&#125; 此时，有一个子类同时实现了这两个接口： 12public class AnotherSubClass implements MyInterface, MyOtherInterface &#123;&#125; 此时编译器会报错： 此时必须重写该方法来解决冲突问题。 若想选择某一个接口中的默认方法，重写的方法可以为： 123456public class AnotherSubClass implements MyInterface, MyOtherInterface &#123; @Override public String getName() &#123; return MyInterface.super.getName(); // 使用的是MyInterface中默认方法 &#125;&#125; 2 接口中的静态方法Java8中接口可以定义静态方法，使用static修饰。 12345public interface MyInterface &#123; static void show() &#123; System.out.println("this is myInterface static method"); &#125;&#125;]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Java8新特性之Optional容器类]]></title>
    <url>%2F2018%2F04%2F25%2F03%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional%E5%AE%B9%E5%99%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Optional&lt;T&gt;类是一个容器类，代表一个值存在或者不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。 容器类是用来封装对象的。泛型T就是需要封装的类。 1 Optional类常用的方法一、Optional.of(T t)：创建一个Optional实例。 123Optional&lt;User&gt; userOptional = Optional.of(new User());User user = userOptional.get();System.out.println(user); 注意：在实际开发中，of方法的形参从其他地方传入时有可能为null，此时会抛出空指针异常。 二、Optional.empty()：创建一个空的Optional实例。 12Optional&lt;User&gt; emptyOptional = Optional.empty();User user = emptyOptional.get(); 在第二局抛出异常：java.util.NoSuchElementException: No value present。 三、Optional.ofNullable(T t)：若t不为null，创建Optional实例。否则创建空实例。 12Optional&lt;Object&gt; nullableOptional = Optional.ofNullable(null);Object o = nullableOptional.get(); 在第二局抛出异常：java.util.NoSuchElementException: No value present。 ofNullable()方法结合了of()和empty()方法，源码如下： 123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value == null ? empty() : of(value);&#125; 四、boolean isPresent()：判断是否包含值。 1234Optional&lt;Object&gt; nullableOptional = Optional.ofNullable(null);if (nullableOptional.isPresent()) &#123; // 不包含值，为false Object o = nullableOptional.get();&#125; 五、T orElse(T other)：如果调用对象包含值，返回该值，否则返回other。 12Optional&lt;User&gt; nullableOptional = Optional.ofNullable(new User());User user = nullableOptional.orElse(new User("123", "嘻嘻", 21, 1000.0)); 如果有值，返回该值，否则用new User(&quot;123&quot;, &quot;嘻嘻&quot;, 21, 1000.0)代替。 六、T orElseGet(Supplier&lt;? extends T&gt; other)：如果调用对象包含值，返回该值，否则返回other获取的值。 12Optional&lt;User&gt; nullableOptional = Optional.ofNullable(new User());User user1 = nullableOptional.orElseGet(() -&gt; new User()); 七：&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)：如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()。 123Optional&lt;User&gt; userOptional = Optional.of(new User("123", "嘻嘻", 21, 1000.0));Optional&lt;String&gt; nameOptional = userOptional.map((user) -&gt; user.getName());System.out.println(nameOptional.get()); 八、&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)：与map类似。要求Function函数式接口的返回值必须是Optional。 123Optional&lt;User&gt; userOptional = Optional.of(new User("123", "嘻嘻", 21, 1000.0));Optional&lt;String&gt; nameOptional = userOptional.flatMap((user) -&gt; Optional.of(user.getName()));System.out.println(nameOptional.get()); 2 Optional的最佳实践2.1 Optional应该只用于返回类型Optional值应该在遇到它们的地方中处理。 2.2 不要简单的调用get()方法Optional的目的是用来表示此值很可能为空。所以，在使用它之前进行检查是很有必要的。在某些情况下简单的调用get()方法但没有使用isPresent()方法进行检查时，同样会导致空指针异常。 或者你不使用isPresent()方法来进行检查，可以使用orElse()或者orElseGet()方法来给出一个代替的值，来解决空指针的问题。]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>Lambda 表达式</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 Java8新特性之Stream API]]></title>
    <url>%2F2018%2F04%2F22%2F02%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%20API%2F</url>
    <content type="text"><![CDATA[1 什么是Stream Java8的Stream与java.io包中的InputStream和OutputStream是完全不同的概念。它是对集合对象功能的增强。 Stream是对数据的操作，对数据操作需要有数据源（集合、数组），把对数据源的操作想象成对数据的传输，在传输中对数据源做一系列流水线式的中间操作。做完这些操作后，会产生一个新流，原来的数据源是不会发生改变的。 流（Stream）是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 集合讲的是数据，流讲的是计算。 注意： Stream 自己不会存储元素。 Stream 不会改变源对象。相反，它们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的，这意味着它们会等到需要结果的时候才执行。 2 Stream 的操作三个步骤 创建Stream 一个数据源（集合、数组等），获取一个流。 中间操作 一个中间操作链，对数据源的数据进行处理。 终止操作（终端操作） 一个终止操作，执行中间操作链，并产生结果。 2.1 步骤一：创建 Stream一、【方式一】：通过 Collection 系列集合提供的stream()或parallelStream()方法获取流。 stream()获取的是串行流；parallelStream获取的是并行流。（串行流和并行流的区别往下看。） 12List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream(); 二、【方式二】：通过Arrays中的静态方法stream()方法，获取数据流。 12User[] users = new User[10];Stream&lt;User&gt; stream2 = Arrays.stream(users); 三、【方式三】：通过Stream类中的静态方法of()方法，获取流。 12// &lt;T&gt; Stream&lt;T&gt; of(T... values)Stream&lt;String&gt; stream3 = Stream.of("aa", "bb", "cc"); 四、【方式四】：创建无限流 1234// 迭代:&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2);// 生成:&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)Stream.generate(() -&gt; Math.random()); 2.2 步骤二：中间操作2.2.1 筛选和切片filter：接受 Lambda ，从流中排除某些元素。 ​ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); limit(n)：截断流，使其元素不超过给定数量。 ​ Stream&lt;T&gt; limit(long maxSize); skip(n)：跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，一limit(n)互补。 ​ Stream&lt;T&gt; skip(long n); distinct：筛选，通过流所生成元素的hashCode()和equals()去除重复元素。 ​ Stream&lt;T&gt; distinct(); 示例： 有数据源： 1234567List&lt;User&gt; userList = Arrays.asList( new User("101", "张三", 18, 9999.99), new User("102", "李四", 59, 6666.66), new User("103", "王五", 28, 3333.33), new User("104", "赵六", 8, 7777.77), new User("105", "田七", 38, 5555.55) ); 一、【filter】： 1234567891011@Testpublic void test2() &#123; // 中间操作 Stream&lt;User&gt; stream = userList.stream() .filter((e) -&gt; &#123; System.out.println("Stream API 的中间操作"); return e.getAge() &gt; 35; &#125;); // 终止操作 stream.forEach(System.out::println);&#125; 注意：中间操作是不会执行任何操作，只有执行终止操作以后，所有的中间操作一次性执行全部。这个过程称为惰性求值或延迟加载。 我们没有做迭代操作， 由Stream API 自己完成迭代操作，称作内部迭代。 二、【limit】： 12345678910@Testpublic void test3() &#123; userList.stream() .filter((e) -&gt; &#123; System.out.println("短路"); return e.getSalary() &gt; 5000; &#125;) .limit(2) .forEach(System.out::println); // 终止操作&#125; limit(n)：一旦发现了n条满足条件的数据后，其他后续的迭代操作不再继续进行，提高了效率，称作短路。 三、【skip(n)】： 1234567@Testpublic void test4() &#123; userList.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) // 跳过前2个 .forEach(System.out::println);&#125; 四、【distinct】： 12345678@Testpublic void test4() &#123; userList.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) // 跳过前2个 .distinct() .forEach(System.out::println);&#125; User 类必须重写hashCode()和equals()方法。 2.2.2 映射 map：接受 Lambda ， 将元素转换成其他形式或者提取信息。接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。 ​ &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); flatMap：接受一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连成一个流。 ​ &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 示例： 一、【map】： 12345678@Testpublic void test5() &#123; List&lt;String&gt; list = Arrays.asList("aaa", "bbb", "ccc"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println);&#125; 将集合中的元素全部转换成大写。 123userList.stream() .map(User::getName) .forEach(System.out::println); 提取集合中的元素中的姓名。 二、【flatMap】： 12345678910111213141516public static Stream&lt;Character&gt; filterCharacter(String str) &#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125;@Testpublic void test6() &#123; List&lt;String&gt; list = Arrays.asList("aaa", "bbb", "ccc"); Stream&lt;Character&gt; characterStream = list.stream() .flatMap(TestStreamAPi1::filterCharacter); characterStream.forEach(System.out::println);&#125; map和flatMap的区别：例如有3个流对象。使用map是将这三个流对象一起放到一个流对象中。使用flatMap是将这三个流对象中的元素一起放到一个流对象中。 有点类似于集合中的add和addAll方法。 2.2.3 排序sorted()：自然排序。（Comparable） sorted(Comparator com)：定制排序。（comparator） 示例： 一、【sorted()】： 12345678@Testpublic void test7() &#123; List&lt;String&gt; list = Arrays.asList("ccc", "aaa", "ddd", "bbb"); list.stream() .sorted() .forEach(System.out::println);&#125; 该例子中，默认使用String实现的Comparable中的compareTo方法排序。 二、【sorted(Comparator com)】： 123456789userList.stream() .sorted((e1, e2) -&gt; &#123; if (e1.getAge().equals(e2.getAge())) &#123; return e1.getName().compareTo(e2.getName()); &#125; else &#123; return e1.getAge().compareTo(e2.getAge()); &#125; &#125;) .forEach(System.out::println); 2.3 步骤三：终止操作2.3.1 查找与匹配allMatch：检查是否匹配所有元素。 anyMatch：检查是否至少匹配一个元素。 noneMatch：检查是否没有匹配所有元素。 findFirst：返回第一个元素。 findAny：返回当前流中任意元素。 count：返回流中元素的总个数。 max：返回流中的最大值。 min：返回流中的最小值。 示例： 模型准备： 123456789101112131415@Getter@Setterpublic class User &#123; private String id; private String name; private Integer age; private Double salary; private Status status; public enum Status &#123; BUSY, // 繁忙 FREE, // 空闲 VOCATION // 假期 &#125;&#125; 数据源准备： 1234567List&lt;User&gt; userList = Arrays.asList( new User("101", "张三", 18, 9999.99, User.Status.FREE), new User("102", "李四", 59, 6666.66, User.Status.BUSY), new User("103", "王五", 28, 3333.33, User.Status.VOCATION), new User("104", "赵六", 8, 7777.77, User.Status.FREE), new User("105", "田七", 38, 5555.55, User.Status.BUSY)); 一、【boolean allMatch(Predicate&lt;? super T&gt; predicate);】：是否匹配所有元素。 12boolean b1 = userList.stream() .allMatch((e) -&gt; e.getStatus().equals(User.Status.BUSY)); 判断是否匹配所有元素。结果为false。 二、【boolean anyMatch(Predicate&lt;? super T&gt; predicate);】：是否至少匹配一个元素。 12boolean b2 = userList.stream() .anyMatch((e) -&gt; e.getStatus().equals(User.Status.BUSY)); 判断是否至少匹配一个元素，返回true。 三、【boolean noneMatch(Predicate&lt;? super T&gt; predicate);】：是否没有匹配所有元素。 12boolean b3 = userList.stream() .noneMatch((e) -&gt; e.getStatus().equals(User.Status.BUSY)); 返回false。 四、【Optional&lt;T&gt; findFirst();】：返回第一个元素。 123Optional&lt;User&gt; first = userList.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); 取出工资最低的人。 五、【Optional&lt;T&gt; findAny();】：返回当前流中的任意元素。 123Optional&lt;User&gt; any = userList.stream() .filter((e) -&gt; e.getStatus().equals(User.Status.FREE)) .findAny(); 从空闲状态的人中任意取出一个。 六、【long count();】：返回六中元素的总个数。 1long count = userList.stream().count(); 七、【Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);】：返回流中最大值。 12Optional&lt;User&gt; max = userList.stream() .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); 根据工资获取流中最大值。 八、【Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);】：返回流中最小值。 123Optional&lt;Double&gt; min = userList.stream() .map(User::getSalary) // 提取出工资 .min(Double::compare); 获取流中最小的工资。 2.3.2 归约与收集归约： reduce(T identity, BinaryOperator)或reduce(BinaryOperator)：可以将流中的元素反复结合起来，得到一个值。 收集： collect：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总的方法。 一、T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);： 123List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); 将集合中的元素加起来。 第一个参数是起始值，将起始值0作为了x，从流中取出一个元素作为了y，进行x+y。将x+y的结果作为了x，从流中取出下一个元素，进行x+y。以此类推。 二、【Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);】： 123Optional&lt;Double&gt; reduce = userList.stream() .map(User::getSalary) .reduce((x, y) -&gt; x + y); 为什么两个方法的返回值不一样呢？ 因为第一个方法有起始值，其结果可能为空；而第二个方法结果有可能为空，所以用Optional封装，避免空指针。 备注：map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。 三、【&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 把姓名提取出来转成集合List&lt;String&gt; collect = userList.stream() .map(User::getName) .collect(Collectors.toList()); // 总数Long count = userList.stream() .collect(Collectors.counting());// 平均值Double avg = userList.stream() .collect(Collectors.averagingDouble(User::getSalary));// 总和Double sum = userList.stream() .collect(Collectors.summingDouble(User::getSalary));// 最大值Optional&lt;User&gt; max = userList.stream() .collect(Collectors.maxBy((user1, user2) -&gt; user1.getSalary().compareTo(user2.getSalary())));// 最小值Optional&lt;Double&gt; min = userList.stream() .map(User::getSalary) .collect(Collectors.minBy(Double::compare));// 根据状态分组Map&lt;User.Status, List&lt;User&gt;&gt; map = userList.stream() .collect(Collectors.groupingBy(User::getStatus));// 多级分组：先根据状态分，再根据年龄段分。Map&lt;User.Status, Map&lt;String, List&lt;User&gt;&gt;&gt; map2 = userList.stream() .collect(Collectors.groupingBy(User::getStatus, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &lt;= 35) &#123; return "青年"; &#125; else if (e.getAge() &lt;= 50) &#123; return "中年"; &#125; else &#123; return "老年"; &#125; &#125;)));// 分区：true一个区，false一个区Map&lt;Boolean, List&lt;User&gt;&gt; map3 = userList.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; 8000));// 汇总DoubleSummaryStatistics summaryStatistics = userList.stream() .collect(Collectors.summarizingDouble(User::getSalary));System.out.println(summaryStatistics.getSum());System.out.println(summaryStatistics.getAverage());System.out.println(summaryStatistics.getCount());System.out.println(summaryStatistics.getMax());System.out.println(summaryStatistics.getMin());// 拼接字符串// 没有分隔符：张三李四王五赵六田七String str1 = userList.stream() .map(User::getName) .collect(Collectors.joining());// 使用","作为分隔符：张三,李四,王五,赵六,田七String str2 = userList.stream() .map(User::getName) .collect(Collectors.joining(","));// 使用","作为分隔符，首位添加"==="：===张三,李四,王五,赵六,田七===String str3 = userList.stream() .map(User::getName) .collect(Collectors.joining(",", "===", "===")); 3 练习一、【给定数字列表，如何返回一个由每个数的平方构成的列表。】 1234Integer[] nums = new Integer[]&#123;1, 2, 3, 4, 5&#125;;Arrays.stream(nums) .map((x) -&gt; x * x) .forEach(System.out::println); 二、【用map和reduce方法，数一数流中有多少个User。】： 1234Optional&lt;Integer&gt; count = userList.stream() .map((e) -&gt; 1) .reduce(Integer::sum);System.out.println(count.get()); 4 并行流和串行流4.1 了解 Fork\Join框架Fork\Join框架：就是在必要的情况下，将一个大任务，进行进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。 Fork\Join框架和传统线程池的区别：采用”工作窃取“模式(work-stealing)： 当执行新的任务时，它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能。 4.2 并行流并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过parallel()与sequential()在并行流与顺序流之间进行切换。]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>Lambda 表达式</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 Java8新特性之Lambda 表达式]]></title>
    <url>%2F2018%2F03%2F24%2F01%20Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1 为什么使用Lambda表达式Lambda 是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更加简洁、灵活的代码。 2 Lambda 表达式引入案例现有集合如下： 1234567List&lt;User&gt; userList = Arrays.asList( new User("101", "张三", 18, 9999.99), new User("102", "李四", 59, 6666.66), new User("103", "王五", 28, 3333.33), new User("104", "赵六", 8, 7777.77), new User("105", "田七", 38, 5555.55)); 1234567public class User &#123; private String id; private String name; private Integer age; private Double salary; // 省略getter、setter和构造方法&#125; 有需求：获取公司中年龄小于35的员工信息。 一、【原始写法】： 123456789public List&lt;User&gt; filterUsersAge(List&lt;User&gt; users) &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (User user : users) &#123; if (user.getAge() &lt;= 35) &#123; list.add(user); &#125; &#125; return list;&#125; 测试： 1234567@Testpublic void test1() &#123; List&lt;User&gt; list = filterUsersAge(userList); for (User user : list) &#123; System.out.println(user); &#125;&#125; 但是此时如果需求变了，要求获取公司中工资大于 5000 的员工信息。这是就需要重写一个方法来完成需求。这样做自然不好。 二、【优化方式一】：策略设计模式 策略模式，就是将一个算法的不同实现封装成一个个单独的类，这些类实现同一个接口，使用者直接使用该接口来访问具体的算法。这个样子，使用者就可以使用不同的算法来实现业务逻辑了。 首先定义一个接口： 123public interface MyPredicate&lt;T&gt; &#123; public boolean compare(T t);&#125; 然后根据需求获取公司中年龄小于35的员工信息，编写实现类： 123456public class FilterUsersForAge implements MyPredicate&lt;User&gt; &#123; @Override public boolean compare(User user) &#123; return user.getAge() &lt;= 35; &#125;&#125; 优化原始的写法： 123456789public List&lt;User&gt; filterUsers(List&lt;User&gt; users, MyPredicate&lt;User&gt; myPre) &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (User user : users) &#123; if (myPre.compare(user)) &#123; list.add(user); &#125; &#125; return list;&#125; 测试： 1234567@Testpublic void test2() &#123; List&lt;User&gt; users = filterUsers(userList, new FilterUsersForAge()); for (User user : users) &#123; System.out.println(user); &#125;&#125; 此时如果需要改成了获取公司中工资大于 5000 的员工信息。只需要重写一个类实现MyPredicate。 123456public class FilterUsersForSalary implements MyPredicate&lt;User&gt; &#123; @Override public boolean compare(User user) &#123; return user.getSalary() &gt;= 5000; &#125;&#125; 测试： 1234567@Testpublic void test2() &#123; List&lt;User&gt; users = filterUsers(userList, new FilterUsersForSalary()); for (User user : users) &#123; System.out.println(user); &#125;&#125; 调用filterUsers方法时使用不同的实现类做形参即可。 三、【优化方式二】：匿名内部类 虽然优化方式一的策略设计模式很好的解决了需求。但是如果两个实现类都只调用一次的话，这样写就太浪费了。如果改类只用一次的话，则可以使用匿名内部类代替。 123456789101112131415161718192021222324252627@Testpublic void test3() &#123; List&lt;User&gt; list = filterUsers(userList, new MyPredicate&lt;User&gt;() &#123; @Override public boolean compare(User user) &#123; return user.getAge() &lt;= 35; &#125; &#125;); for (User user : list) &#123; System.out.println(user); &#125;&#125;@Testpublic void test4() &#123; List&lt;User&gt; list = filterUsers(userList, new MyPredicate&lt;User&gt;() &#123; @Override public boolean compare(User user) &#123; return user.getSalary() &gt;= 5000; &#125; &#125;); for (User user : list) &#123; System.out.println(user); &#125;&#125; 四、【优化方式三】：Lambda 表达式 虽然优化方式二比优化方式一的代码简洁了不少，但是我们会发现其中有不少都是重复的代码。通过观察发现，其实有用的代码只有user.getAge() &lt;= 35和user.getSalary() &gt;= 5000两句。 因此可以使用Lambda 表达式。 12345678910@Testpublic void test5() &#123; List&lt;User&gt; users = filterUsers(userList, (e) -&gt; e.getAge() &lt;= 35); users.forEach(System.out::println); System.out.println("----------------"); List&lt;User&gt; users2 = filterUsers(userList, (e) -&gt; e.getSalary() &gt;= 5000); users2.forEach(System.out::println);&#125; 五、【优化方式四】：Steam API（下一篇介绍） 12345@Testpublic void test6() &#123; userList.stream().filter((e) -&gt; e.getAge() &lt;= 50) .forEach(System.out::println);&#125; 3 Lambda 表达式基础语法Java8中引入了新的操作符 -&gt; ，称作箭头操作符或 Lambda 操作符。 箭头操作符将 Lambda 表达式拆分成两部分： 左侧：Lambda 表达式的参数列表。 参数列表对应的是接口中抽象方法的参数列表。 右侧：Lambda 表达式中所需要执行的功能。即 Lambda 体。 对接口中抽象方法的实现功能。 3.1 语法格式一：无参数、无返回值 接口中的抽象方法无参数、无返回值。 () -&gt; System.out.println(&quot;hello Lambda&quot;); 示例： 123456789101112131415161718@Testpublic void test1() &#123; // 传统写法 Runnable r = new Runnable() &#123; int num = 0; @Override public void run() &#123; System.out.println("hello Lambda!" + num); &#125; &#125;; r.run(); System.out.println("====================="); // Lambda 表达式写法 Runnable r1 = () -&gt; System.out.println("hello Lambda!" + num); r1.run();&#125; 注意事项：如果在匿名内部类中使用了同级别的局部变量时，在JDK1.8以前该变量必须加上final修饰的。但从jdk1.8开始，该变量可以省略final修饰，其已经默认为final变量，不能修改。 3.2 语法格式二：有参数、无返回值 接口中的抽象方法有一个参数，无返回值。 12345@Testpublic void test2() &#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept("hello Lambda");&#125; 执行程序，控制台打印：hello Lambda 3.3 语法格式三：若只有一个参数，小括号可以省略 接口中的抽象方法若只有一个参数，小括号可以省略不写。 语法格式二可以写成：Consumer&lt;String&gt; con = x -&gt; System.out.println(x); 3.4 语法格式四：有两个以上参数，Lambda 体中有多条语句，有返回值 接口中的抽象方法有两个以上参数，Lambda 体中有多条语句，有返回值。 1234567@Testpublic void test3() &#123; Comparator&lt;Integer&gt; con = (x, y) -&gt; &#123; System.out.println("hello Lambda"); return Integer.compare(x, y); &#125;;&#125; 注意：如果有多条语句，Lambda 体必须使用大括号{}。 3.5 语法格式五：只有一条语句，retrun和大括号可以省略 若Lambda 体中只有一条语句，return和{}都可以不省略不写。 1234@Testpublic void test3() &#123; Comparator&lt;Integer&gt; con = (x, y) -&gt; Integer.compare(x, y);&#125; 3.6 语法格式六：类型推断Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器可以通过上下文推断出数据类型，即类型推断。 3.7 语法格式七：需要函数式接口的支持函数式接口：若接口中只有一个抽象方法的接口，成为函数式接口。可以使用注解@FunctionalInterface修饰，可以检查是否是函数式接口。 换句话说，使用@FunctionalInterface修饰的接口必须是函数式接口，接口中只能有一个抽象方法。 4 四大内置核心函数式接口一、【Consumer&lt;T&gt;】：消费型接口。 抽象方法：void accept(T t); 二、【Supplier&lt;T&gt;】：供给型接口。 抽象方法：T get(); 三、【Function&lt;T,R&gt;】：函数型接口。 抽象方法：R apply(T t); 四、【Predicate&lt;T&gt;】：断言型接口。 抽象方法：boolean test(T t); 除了以上接口，还有以上接口的子接口，用法差不多。 5 方法引用和构造器引用5.1 方法引用（method reference）若Lambda 体中的内容有方法已经实现了，我们可以使用方法引用。 可以理解为方法引用是 Lambda 表达式的另外一种表现形式。 主要有三种语法格式： 对象::实例方法名 类::静态方法名 类::实例方法名 方法引用的前提条件： 实现抽象方法中的参数列表和返回值类型得与 Lambda 体中已实现方法的参数列表和返回值类型一致。 若 Lambda 参数列表中的第一个参数是实例方法的调用者，二第二个参数是实例方法的参数时，可以使用类::实例方法名。 一、【对象::实例方法名】： 12345678910111213141516@Testpublic void test1() &#123; // Lambda 表达式 Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); // 方法引用 Consumer&lt;String&gt; con1 = System.out::println;&#125;@Testpublic void test2() &#123; User user = new User(); // Lambda 表达式 Supplier&lt;String&gt; sup = () -&gt; user.getName(); // 方法引用 Supplier&lt;String&gt; sup2 = user::getName;&#125; 二、【类::静态方法名】： 123456@Testpublic void test3() &#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); // 方法引用 Comparator&lt;Integer&gt; com2 = Integer::compare;&#125; 三、【类::实例方法名】： 123456@Testpublic void test4() &#123; BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y); // 方法引用 BiPredicate&lt;String, String&gt; bp2 = String::equals;&#125; 注意： Lambda 表达式的第一个参数是方法的调用者，第二个参数是方法的参数时，就可以使用类::实例方法名的方式。 其中，x是equals方法的调用者，y是equals方法的参数。 5.2 构造器引用格式：类::new。 注意：需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表保持一致。 1234567@Testpublic void test5() &#123; Supplier&lt;User&gt; sup = () -&gt; new User(); // 构造器引用 Supplier&lt;User&gt; sup2 = User::new; // 无参构造 User user = sup2.get();&#125; 12345678910111213141516171819// 若User有构造器public User(String id) &#123; this.id = id;&#125;public User(String id, Integer age) &#123; this.id = id; this.age = age;&#125;@Testpublic void test6() &#123; Function&lt;String, User&gt; fun = (x) -&gt; new User(x); // 构造器引用 Function&lt;String, User&gt; fun2 = User::new; // 一个参数构造 fun2.apply("101"); BiFunction&lt;String, Integer, User&gt; bf = (x, y) -&gt; new User(x, y); BiFunction&lt;String, Integer, User&gt; bf2 = User::new; // 两个参数构造&#125; 5.3 数组引用语法：类型[]::new 1234567@Testpublic void test7() &#123; Function&lt;Integer, String[]&gt; fun = (x) -&gt; new String[x]; // 数组引用 Function&lt;Integer, String[]&gt; fun2 = String[]::new; String[] arr = fun2.apply(20); // 数组的长度为20&#125;]]></content>
      <categories>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>Lambda 表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
